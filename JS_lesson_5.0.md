# ФУНКЦИИ.
***
## Пример один:

Вы только хотели отдохнуть, но вдруг получили ТЗ с пометкой «срочно».

- Я хочу поехать в отпуск. Говорят, в Иркутске водится вкусный омуль, питерская корюшка мне совсем приелась.

- Посчитайте, сколько бонусных воздушных миль я смогу получить с перелёта компанией «Offly». Моё чутье охотника за скидками подсказывает, что тут есть, чем поживиться.

- Расстояние до Иркутска 4125 км. Количество миль равно 25% от этого расстояния.

**Жду результата!**

Для начала проясним, что такое «воздушные мили». Так называются бонусы от авиакомпаний, которые можно накапливать после каждого полёта, а затем «оплатить» ими перелёт в какой-нибудь город. Бонусные мили не всегда связаны с настоящими физическими милями. Зачастую это бонусные очки, которые можно накопить до какой-то суммы. Бонусные мили начисляются по-разному. В «Offly», как мы уже узнали, бонусы — процент от расстояния перелёта.

В нашем коде расстояние хранится в переменной distance, а процент уже переведён в дробное число и хранится в переменной percent.

Этих значений достаточно, чтобы получить нужное количество миль: умножим расстояние на процент.

```javascript
var percent = 0.25;
var distance = 4125;

var miles = distance * percent;

console.log('За полёт в Иркутск получим ' + miles + ' миль');

```
***
## Пример два:
Вы не первый день работаете  с заказчиком и знаете его шальной характер. Сегодня он летит в Иркутск, а завтра захочет куда-нибудь ещё.

Давайте подстрахуемся и улучшим нашу программу, чтобы она учитывала условие для дальних перелётов.

Если расстояние больше 10500 км, то количество начисленных миль составляет 35% от дальности полёта, а не 25%, как было изначально.
```javascript
var percent = 0.25;
var distance = 4125;

if (distance > 10500) {
  percent = 0.35;
}

var miles = distance * percent;

console.log('За полёт в Иркутск получим ' + miles + ' миль');

```
***
## Пример три:
Спасибо за расчёт!

Когда вернусь, хочу ещё слетать на Камчатку, поесть микижи да на вулканы посмотреть.

Сколько я накоплю миль? Лететь аж 9 часов, мои страдания должны быть вознаграждены!

Ваше чутьё вас не подвело! Задумано ещё одно путешествие, а у вас всё готово: формула есть, условие для дальних перелётов учтено.

Добавим расчёт миль для полёта на Камчатку.

Для этого нам придётся повторить все шаги вычислений для первого путешествия. Алгоритм тот же, только расстояние другое, а может, и проценты. Проверим!

Вы можете заметить, что результаты наших расчётов получаются не круглыми. Всё в порядке, это не ошибка, так работают вычисления в JavaScript. Чуть позже мы сделаем числа круглыми. А в дальнейших курсах обсудим, почему так происходит.

```javascript
var percent = 0.25;
var distance = 4125;

if (distance > 10500) {
  percent = 0.35;
}

var miles = distance * percent;

console.log('За полёт в Иркутск получим ' + miles + ' миль');

var percent = 0.25;
var distance = 11000;

if (distance > 10500) {
  percent = 0.35;
}

var miles = distance * percent;

console.log('За полёт на Камчатку получим ' + miles + ' миль');
```

***
## Пример четыре:
Вы уже заметили проблему?

Программа работает, мили считаются, но что будет, если  пойдёт вразнос и заказчик решит слетать ещё в десяток городов? Нам постоянно придётся копировать одну часть кода, менять расстояние, считать, а ещё каждый раз заново объявлять одни и те же переменные, что нарушает правила языка. Мы, конечно, справимся с поставленной задачей, но потратим много времени, да и код разрастётся до сотни строк.

Есть ли более удобный и грамотный способ сделать вычисления без копирования? Есть! Написать функцию.

Функция — кусок кода, который можно написать один раз, а затем многократно использовать. Функция не просто содержит в себе значение, как переменная, а выполняет какое-то действие и решает какую-то задачу: считает, сравнивает, ищет. Например, наша функция будет вычислять накопленные мили с перелёта.

Но сначала посмотрим, из чего состоят функции и как они объявляются (создаются) в коде.
```javascript
var functionName = function () {
  // Действия, которые выполняет функция или «тело функции»
};
```
**functionName** — имя переменной, которая содержит в себе функцию. По этому имени мы сможем обращаться к функции и использовать её много раз. Давайте считать, что название переменной это и есть название функции.

Есть и другие способы создания функций, о них мы поговорим позже, в других курсах.

Функции создаются не сложнее условий или циклов. Используем ключевое слово function, дальше добавляем круглые скобки. В фигурных скобках находятся действия, которые функция будет делать каждый раз, как мы к ней обратимся. Помните, как в циклах? Там код внутри { } называется «телом цикла», а здесь «телом функции».

**Напишем функцию calculateMiles для расчёта миль.**

Кстати,обратите внимание на название calculateMiles. Функция буквально вычисляет мили, то есть что-то делает. Это общепринятое правило именования — название функции должно содержать глагол. Так разработчикам удобней ориентироваться в своём и даже чужом коде. Может быть, функцию написал ваш коллега, и вы понятия не имеете, что там внутри. Вам достаточно будет посмотреть на имя функции, чтобы примерно представить, для чего она предназначена.
```javascript

var calculateMiles = function(){
 var percent = 0.25;
 var distance = 4125;

 if (distance > 10500) {
  percent = 0.35;
}

var miles = distance * percent;
console.log('За полёт в Иркутск получим ' + miles + ' миль');

};
```
***
## Пример пять:
Функция готова, а дальше-то что? Как вычислить количество миль?

Чтобы функция начала свою работу, её надо вызвать. Для этого нам и пригодится имя функции. Именно по нему мы обратимся к нашей функции и попросим её выполнить свой код.

Если мы просто выведем функцию console.log(functionName), то увидим в консоли весь код этой функции примерно в таком же виде, как его и написали, но никаких вычислений не произойдёт.

Как же тогда запустить код из тела функции?

Нужно обратиться к функции по её имени, а затем указать круглые скобки.

**functionName();**

Обратите внимание, что вызов функции должен идти в коде после её определения.

Давайте проверим, как работает вызов функции, и вызовем нашу функцию calculateMiles.
```javascript
var calculateMiles = function () {
  var distance = 4125;
  var percent = 0.25;
  if (distance > 10500) {
    percent = 0.35;
  }
  var miles = distance * percent;
  console.log('За полёт в Иркутск получим ' + miles + ' миль');
};


calculateMiles();
```
***
## Пример шесть:
Мы написали функцию, вызвали её и посчитали мили, накопленные полётом в Иркутск. А что с полётом на Камчатку? Как посчитать результат второго путешествия?

Тут пригодится очередная фишка функций.

Мы можем записать хоть десять вызовов calculateMiles(), результат будет одинаковым, потому что внутри функции находятся переменные с фиксированными значениями, подходящими только для полёта в Иркутск. То есть **только для одного случая.**

Внутри функции в переменной distance мы храним расстояние до Иркутска. Чтобы найти мили за другой полёт, надо поменять значение этой переменной. Но мы не будем заново переписывать функцию с другим значением distance. Мы сделаем функцию универсальной, чтобы её можно было написать один раз, а затем использовать под разные случаи. Для этого мы будем использовать параметры.

**Параметры** — значения, с помощью которых можно настраивать функции. Так мы можем узнать результат работы функции для разных случаев.

Посмотрим, как это работает.
```javascript
var showTime = function (hours, minutes) {
  console.log('Текущее время: ' + hours + ':' + minutes);
};

showTime(3, 15);    // Выведет: Текущее время: 3:15
showTime(16, 20);   // Выведет: Текущее время: 16:20
```
Чтобы функция работала с параметрами, их надо как-то передать и дать им названия. Разберёмся, как это делать.

1. **Задаём параметры.**
```javascript
var showTime = function (hours, minutes) {
  …
};
```
В момент объявления функции, в круглых скобках, мы создаём параметры. Здесь всё, как с переменными: сначала задаём параметрам имена, которые описывают, что за значения будут в них записаны. Если параметров несколько, они записываются через запятую.

2. **Используем параметры.**
```javascript
var showTime = function (hours, minutes) {
  console.log('Текущее время: ' + hours + ':' + minutes);
};
```
Параметры работают так же, как переменные. Мы подставляем их вместо фиксированных значений в операции внутри функции. При выполнении кода вместо каждого параметра подставится его значение.

3. **Функция получает значения параметров**
```javascript
showTime(3, 15);    // Выведет: Текущее время: 3:15
showTime(16, 20);   // Выведет: Текущее время: 16:20
```
В предыдущих шагах мы разобрали, как функция работает с полученными параметрами. Но ещё не обсудили как сделать так, чтобы функция их получила. В момент вызова функции мы указываем в круглых скобках те значения, которые окажутся в параметрах. Мы пишем showTime(16, 20) и вместо hours в теле функции подставляется 16, а вместо minutes число 20.

Давайте улучшим наш код, наконец, сделаем функцию **calculateMiles** универсальной и посчитаем накопленные мили за второй полёт.

Кстати,правильно говорить «функция принимает параметры», но при этом мы «передаём функции **аргументы**». Почему аргументы? Речь же шла о параметрах! Дело в том, что параметрами называются значения, которые мы задаём в момент объявления функции. Их же мы используем и в теле функции. А аргументами называют значения, которые мы передаём в функцию при её вызове.
```javascript
var calculateMiles = function (distance) {
  var percent = 0.25;
  if (distance > 10500) {
    percent = 0.35;
  }
  var miles = distance * percent;
  console.log('За полёт получим ' + miles + ' миль');
};

calculateMiles(4125);
calculateMiles(11000);

```

***
## Пример семь:
Отвлечёмся ненадолго от подсчёта миль. С аргументами есть один нюанс — передавать их надо в том же порядке, в котором объявлены параметры функции.

Рассмотрим на примере. У нас есть функция getFavoriteBook, которая выводит в консоль сообщение о любимой книге пользователя. У неё есть два параметра: первый называется userName (имя пользователя), второй bookName (название книги).
```javascript
var getFavoriteBook = function (userName, bookName) {
  console.log('Меня зовут ' + userName + '. Моя любимая книга: ' + bookName);
}
```
Допустим, нашего пользователя зовут Семён, а его любимая книга «Ёжик в тумане». Передадим эти аргументы в функцию. Сначала название книги, а затем имя пользователя:
```javascript
var getFavoriteBook = function (userName, bookName) {
  // Параметр userName хранит 'Ёжик в тумане'
  // Параметр bookName хранит 'Семён'
  …
}

// Вызываем функцию
getFavoriteBook('Ёжик в тумане', 'Семён');
// Выведет: Меня зовут Ёжик в тумане. Моя любимая книга: Семён
```
Кажется что-то пошло не так. Почему мы получили такой результат? Мы ведь передали имя пользователя и название книги — всё, как положено.

Всё дело в порядке переданных значений. Параметры работают, как переменные — значение из аргумента записывается в параметр, а потом используется внутри функции по имени. В нашем случае всё так и произошло. Первый параметр функции — userName, первый аргумент — 'Ёжик в тумане'. Этот аргумент и записался в параметр userName, а аргумент 'Семён' стал параметром bookName. Вы, конечно, знаете, где тут имя, а где название книги, а вот JavaScript нет. Он всё понимает буквально: что первым передали, то и стало первым параметром. Потому что порядок аргументов соответствует порядку параметров в функции. У нас параметры записаны в таком порядке: userName, bookName. Значит, первым должно быть передано имя пользователя, а затем название книги. И никак иначе.
```javascript
var getFavoriteBook = function (userName, bookName) {
  // Параметр userName хранит 'Семён'
  // Параметр bookName хранит 'Ёжик в тумане'
  …
}

// Вызываем функцию
getFavoriteBook('Семён', 'Ёжик в тумане');
// Выведет: Меня зовут Семён. Моя любимая книга: Ёжик в тумане
```
Видите, мы передали аргументы в правильном порядке и сообщение стало корректным.

Обратите внимание, если у функции указан параметр, но аргумент не передан, то значение параметра в теле функции будет undefined — то есть ничего. Будьте внимательны.

Потренируемся вызывать функцию с разным порядком аргументов.

Кстати,в примере мы работали со строками, ещё веселей обстоит ситуация с числами. Если в функцию в неправильном порядке переданы значения разных типов, например, числа и строки, могут получиться неожиданные результаты. Например, может произойти конкатенация и число сложится со строкой, результатом будет строка. Или вы можете получить значение NaN, что означает «not a number». Оно говорит о том, что невозможно найти результат математической операции.

```javascript
var showGreeting = function (name, age) {
  console.log('Привет! Меня зовут ' + name + '. Мне ' + age + ' лет.');
};
showGreeting();           //Привет! Меня зовут undefined. Мне undefined лет.
showGreeting(5);          //Привет! Меня зовут 5. Мне undefined лет.
showGreeting(5,'Настя');  //Привет! Меня зовут 5. Мне Настя лет.
showGreeting('Настя',5);  //Привет! Меня зовут Настя. Мне 5 лет.
```
***
## Пример восемь:
А что, если нам нужно получить значение из функции и как-то дальше его использовать?

Функции умеют возвращать результат своей работы. Мы уже говорили о том, что означает «вернуть значение» в этом задании в главе «Знакомство с JavaScript». Загляните туда, если вам нужно освежить знания.

Если кратко, то функция может выполнить код и отдать результат операций для дальнейшей работы с этим результатом. Он подставится в то место кода, где мы вызвали функцию.
```javascript
var increaseByTwo = function (number) {
  var sum = 2 + number;
  return sum;
};

increaseByTwo(1); // Функция вернёт 3
increaseByTwo(2); // Функция вернёт 4
```
Как работает код из примера?

Чтобы функция вернула значение, мы используем оператор return. После оператора указываем, что именно надо вернуть. В нашем случае значение переменной sum. Когда программа доходит до строки с return, функция отдаёт результат своей работы и выполнение кода из тела функции останавливается, иными словами происходит выход из функции.

**Несколько вещей, которые нужно знать:**

- Код, написанный на **новой строке** после return, не выполняется.
- Функция не может вернуть сразу много значений, она возвращает **только один** результат.
- Если внутри функции нет return или после return не указано, какое значение нужно вернуть, функция вернёт undefined, иными словами, **ничего**.
- Как было сказано выше, результат работы функций можно использовать в других операциях.
```javascript
console.log('Сумма чисел: ' + increaseByTwo(1));
// Выведет: Сумма чисел: 3

console.log('Сумма чисел: ' + increaseByTwo(2));
// Выведет: Сумма чисел: 4
```
Кстати, в JavaScript есть встроенные функции языка, которые возвращают результат своей работы. Таких функций очень много. Вот те из них, которые мы будем использовать в заданиях этой главы для округления чисел:

Math.ceil(number) — принимает на вход число и округляет его до целого в большую сторону
Math.floor(number) — делает то же самое, только округляет в меньшую сторону.
Math.round(number) — округляет число до ближайшего целого значения.
Округлим количество миль в нашей функции calculateMiles. Где это видано, чтобы начислялось дробное число миль?

```javascript
var calculateMiles = function (distance) {
  var percent = 0.25;
  if (distance > 10500) {
    percent = 0.35;
  }
  var miles = Math.floor(distance * percent);
  return miles;
};

console.log('За перелёт в Иркутск получим ' + calculateMiles(4125) + ' миль');
console.log('За перелёт на Камчатку получим ' + calculateMiles(11000) + ' миль');
```

***
## Конспект по функциям(1):
Пример функции.
```javascript
var calculateSum = function (numberFirst, numberSecond) {
  var sum = numberFirst + numberSecond;
  return sum;
};

calculateSum();     // Вернёт NaN
calculateSum(2);    // Вернёт NaN
calculateSum(2, 5); // Вернёт 7
calculateSum(9, 5); // Вернёт 14
```

В этом примере:

- **calculateSum** — имя, по которому можно обратиться к функции.
- **numberFirst, numberSecond** — параметры функции.
- **return sum;** — место кода, где происходит возвращение sum и выход из функции.
- **calculateSum(2, 5);** — аргументы, которые передаются в функции при вызове. Порядок аргументов такой же, как у параметров функции. Первый аргумент 2 записывается в первый параметр numberFirst, аргумент 5 записывается в параметр numberSecond. Важно соблюдать порядок параметров при вызове функции, чтобы избежать неочевидных ошибок.

***
## Пример девять:
Появилась новая задача. Теперь заказчик хочет копить мили и на рабочих поездках.

В командировки он летает другим перевозчиком — «воздухоФлот». У компании хитрая система накопления миль. Пассажиры бизнес-класса получают **22%** от всего пути, а пассажиры эконома только **18%**. При этом, если расстояние превышает **3500км**, то процент увеличивается ещё на **15%**.

Для новой задачи создадим новую функцию и закрепим уже полученные знания.

Название прошлой функции для расчёта миль **calculateMiles** точно описывает цель этой функции и подходит для новой задачи. Оставим его.

Новая функция будет принимать на вход два параметра: расстояние и какой-то знак, который укажет программе класс перелёта. С расстоянием всё просто — назовём параметр distance.

А что делать со вторым параметром?

В нашем случае для второго параметра достаточно только два варианта — бизнес-класс или нет. Потому что процент возрастает только для бизнес-класса, и нам важно не упустить именно этот момент и начислить дополнительные проценты. В таком случае подойдёт параметр, который будет содержать только булевы значения (true и false).
Пускай **true** обозначает бизнес-класс, а **false** всё остальное.

Осталось определиться с названием второго параметра. Подобные значения называют флагами, и называют их особым образом. Например, в нашем случае подойдёт название isBusinessClass. То есть переменная как бы задаёт вопрос своему содержимому «Сейчас у нас бизнес-класс?», а содержимое отвечает на этот вопрос «да» (**true**) или «нет» (**false**).

```javascript
var calculateMiles = function (distance, isBusinessClass){
  if(isBusinessClass){
    return distance * 0.22;
    }
  else{
    return distance * 0.18
    }
  };
```
***
## Пример десять:
Помните, мы говорили о том, что функция может возвращать результат своей работы, и подставляли вызов функции сразу в выражение? Примерно так:
```javascript
console.log('За перелёт получим ' + calculateMiles(4125) + ' миль');
```
А сейчас давайте напишем код более грамотно.

Раз функция возвращает значение, которое можно использовать где-то ещё (подставить в строку, добавить в математическую операцию), почему бы не записать результат работы этой функции в переменную и использовать именно её? Так код станет удобней читать и править.

Представьте большую программу с кодом на сотни строк. Вы несколько раз используете вызов функции внутри каких-то выражений, и программа работает. А потом вы понимаете, что надо вызвать эту же функцию с другими аргументами, и вам или вашему коллеге приходится искать по всему коду эти вызовы функции и их исправлять. А если вы что-то пропустите, программа будет работать некорректно.
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  if (isBusinessClass) {
    return distance * 0.22;
  } else {
    return distance * 0.18;
  }
};
var milesEconom = calculateMiles(3000, false);
var milesBusiness = calculateMiles(3000, true);
console.log('Эконом-классом воздухоФлота накопишь ' + milesEconom + ' миль');
console.log('Бизнес-классом воздухоФлота накопишь ' + milesBusiness + ' миль');
```
***
## Пример одиннадцать:
Количество бонусных миль в воздухоФлоте зависит и от класса, и от расстояния. Чтобы завершить программу, можно в каждую ветку проверки на класс перелёта добавить проверки на расстояние. Но такой вариант выглядит громоздко.

Логика расчёта процентов довольно сложная, а хочется описать её максимально просто и изящно. Поэтому перед добавлением нового условия давайте изменим структуру существующего кода, но так, чтобы он работал, как прежде. То есть займёмся рефакторингом.

Посмотрим на код calculateMiles. Внутри у нас два выхода из функции:
```javascript

var calculateMiles = function (distance, isBusinessClass) {
  if (isBusinessClass) {
    return …;
  } else {
    return …;
  }
};
```
Получается, если класс эконом, программа в любом случае не зайдёт внутрь первой ветки условия и пойдёт дальше. Поэтому ветка else здесь необязательна, её можно опустить.
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  if (isBusinessClass) {
    return distance * 0.22;
  }
  return distance * 0.18;

};
var milesEconom = calculateMiles(3000, false);
var milesBusiness = calculateMiles(3000, true);
console.log('Эконом-классом воздухоФлота накопишь ' + milesEconom + ' миль');
console.log('Бизнес-классом воздухоФлота накопишь ' + milesBusiness + ' миль');
```

***
## Пример двенадцать:
Первый шаг рефакторинга сделан. Самое главное, что функция работает так же, как и до рефакторинга. Значит можно двигаться дальше. Смотрите, в функции дублируется код для расчёта миль. Выражения отличаются только значением процентов:
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  if (isBusinessClass) {
    return distance * 0.22;
  }
  return distance * 0.18;
};
```
Давайте взглянем на решение с другой стороны: что если в условиях считать процент, а не дублировать расчёт миль? Мы можем переформулировать задачу так, что базовый процент равен 18, а если класс перелёта бизнес, то процент увеличивается на 4. Затем в конце функции один раз считаем и возвращаем мили.
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  // Вводим процент
  if (isBusinessClass) {
    // Изменяем процент
  }
  // Рассчитываем и возвращаем мили
};
```
Второй шаг рефакторинга такой: создаём переменную percent, которая будет меняться в зависимости от условия, а возвращать из функции будем результат выражения distance * percent.

Так код станет понятней, да и **точка выхода из функции** будет только одна. Функцию станет проще читать, потому что условия для для изменения процента теперь можно делать не вложенными, а последовательными.



```javascript
var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  return distance * percent;
};

var milesEconom = calculateMiles(3000, false);
var milesBusiness = calculateMiles(3000, true);

console.log('Эконом-классом воздухоФлота накопишь ' + milesEconom + ' миль');
console.log('Бизнес-классом воздухоФлота накопишь ' + milesBusiness + ' миль');

```
**Точка выхода из функции — место, где функция прекращает свою работу и отдаёт результат наружу.**
***
## Пример тринадцать:
Второй шаг рефакторинга позади. В консоли всё те же результаты: 660 миль и 540 миль. Значит, логику мы не испортили, и рефакторинг прошёл успешно.

Благодаря тому, что мы отрефакторили наш код, вписать в функцию ещё один if совсем несложно:
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  if (distance > 3500) {
    // Ещё раз изменяем процент
  }
  return distance * percent;
};
```
А что будет, если мы не введём переменную процента и не сократим количество выходов из функции?

Код calculateMiles будет выглядеть очень страшно. Как-то так:
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  if (isBusinessClass && distance > 3500) {
    return distance * 0.37;
  }
  if (isBusinessClass && distance <= 3500) {
    return distance * 0.22;
  }
  if (!isBusinessClass && distance > 3500) {
    return distance * 0.33;
  }
  return distance * 0.18;
};
```
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  if(distance > 3500){
    percent += 0.15;
    }
  return distance * percent;
};

var milesEconom = calculateMiles(10000, false);
var milesBusiness = calculateMiles(10000, true);

console.log('Эконом-классом воздухоФлота накопишь ' + milesEconom.toFixed() + ' миль');
console.log('Бизнес-классом воздухоФлота накопишь ' + milesBusiness + ' миль');

```
***
## Пример четырнадцать:

Знаешь, я хоть и деловой заказчик, но и мне не чужды простые человеческие мечты. Я очень хочу повидать мир, посетить много далёких городов, например, Токио. Там всё, что я люблю: рыба, природа и технологии. Давай-ка выясним, как мне побыстрей обстряпать это дельце?

Впереди у меня много командировок в два города: в испанскую Валенсию и португальский Лиссабон.

Полётами в какой из городов я быстрее накоплю мили в Токио? Мне нужно 15000 миль. В Валенсию полечу бизнесом, а вот в Лиссабон придётся тащиться экономом.

Жду от тебя ответа! До связи!

Перед нами новая задача и новая программа. Если задуматься, функция подсчёта миль, которую мы написали раньше, нам здесь очень пригодится. Сначала с её помощью мы узнаем, сколько миль можно получить с одного перелёта, а затем выясним, сколько таких полётов нужно совершить, чтобы накопить 15000 миль до Токио. Заказчик хочет слетать и в другие города, но сначала мы решим задачу на одном примере, а потом легко масштабируем решение и для других расстояний.

Мы создадим ещё одну функцию, которая будет считать количество полётов, а затем из неё вызовем нашу первую функцию с подсчётом миль и воспользуемся полученным значением.

Звучит сложней, чем выглядит на самом деле. Хороший код всегда состоит из множества частей, каждая из которых занимается только своей задачей. Как у нас: одна функция считает мили, а другая будет считать полёты. В таком случае очень удобно использовать одну функцию для решения задач другой. Например, чтобы посчитать количество полётов, нам понадобится сначала узнать количество миль, полученных за один полёт по направлению. А как это сделать? Вызвать функцию calculateMiles, записать результат в переменную и использовать в дальнейших вычислениях в функции подсчёта полётов.

Давайте закрепим на практике!

Создадим функцию calculateFlights. Пока рассчитаем полёты для первого варианта, полёта в Валенсию, расстояние туда составляет 3118 км. Напишем функцию за несколько шагов, сначала просто протестируем вызов одной функции из другой.

```javascript
var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  if (distance > 3500) {
    percent += 0.15;
  }
  return distance * percent;
};
var calculateFlights = function (distance, isBusinessClass){
  var miles = calculateMiles(distance, isBusinessClass);
  console.log('Мили за перелёт: ' + miles);
  };
calculateFlights(3118, true);
```
***
## Пример пятнадцать:
еперь, когда мы знаем количество миль за один полёт, ничего не мешает нам узнать, сколько раз придётся слетать по одному маршруту, чтобы заполучить поездку в Токио.

Добавим для функции **calculateFlights** ещё один параметр, который мы пока не использовали. Он будет содержать количество необходимых миль. Сейчас это мили до Токио, но вдруг заказчик захочет накопить на полёт ещё куда-нибудь? Достаточно будет поменять значение аргумента и вызвать функцию.

Раз мы делаем универсальную программу, то имя нового параметра тоже должно быть универсальным. Поэтому название вроде **milesToTokyo** нам не подойдёт, оно слишком конкретное и не переиспользуемое. Выберем **milesTarget**. Такое имя подходит лучше, потому что с таким параметром мы сможем посчитать количество полётов хоть до Сиэтла.

Чтобы получить количество полётов, нам нужно разделить **milesTarget** на мили, накопленные с одного полёта. Обратите внимание, что результат может оказаться не целым числом. Так как речь идёт о полётах, не учитывать дробную часть при округлении неправильно. Например, если необходимо 25.2 полётов для накопления 15000 миль, это значит, что в итоге перелётов должно быть 26. Иначе мы не доберём совсем немного миль. Поэтому в нашей задаче мы округлим результат вычислений с помощью **Math.ceil()**.
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  if (distance > 3500) {
    percent += 0.15;
  }
  return distance * percent;
};

var calculateFlights = function (distance, isBusinessClass, milesTarget) {
  var miles = calculateMiles(distance, isBusinessClass);
  console.log('Мили за перелёт: ' + miles);
  var flights = Math.ceil(milesTarget / miles) //округляем в большую сторону
  console.log('Количество полётов: ' + flights);
};

calculateFlights(3118, true, 15000);

```
***
## Пример шестнадцать:
Теперь у нас есть функция, которая считает, за сколько полётов по одному и тому же маршруту можно накопить необходимое количество миль.

Чтобы узнать, как нашему заказчику скорее оказаться в Токио, надо сравнить количество полётов по каждому из направлений. Для этого нам нужно вызвать функцию **calculateFlights** дважды, для полётов в Валенсию и Лиссабон, с одинаковым значением третьего аргумента (**15000 миль до Токио**).

Теперь, чтобы понять, что выгодней, давайте выясним, сколько раз нужно смотаться по работе в Лиссабон, чтобы наконец оказаться на отдыхе в желанном Токио? Расстояние до столицы Португалии **3617км**.
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  if (distance > 3500) {
    percent += 0.15;
  }
  return distance * percent;
};

var calculateFlights = function (distance, isBusinessClass, milesTarget) {
  var miles = calculateMiles(distance, isBusinessClass);
  var flights = Math.ceil(milesTarget / miles);
  return flights;
};

console.log('Необходимое количество полётов в бизнес-классе до Валенсии: ' +  calculateFlights(3118, true, 15000));
console.log('Необходимое количество полётов в экономе до Лиссабона: ' +  calculateFlights(3617, false, 15000));

```
***
## Пример семнадцать:
Отрефакторим наш код, а уже затем закончим писать программу.

Зачем снова рефакторинг?

Дело в том, что дальше нужно будет сравнить полученные результаты и вывести рекомендации. Получается, нам придётся несколько раз использовать результаты работы функции **calculateFlights**. Поэтому логично и правильно записать эти результаты в переменные и использовать их дальше. Если мы вдруг захотим получить данные для других городов, мы просто изменим значения аргументов в одном единственном месте, а не по всему коду.

Как лучше всего назвать переменные, которые содержат в себе количество полётов до Лиссабона и Валенсии? Первое, что приходит на ум, дать переменным конкретные названия: **flightsToValencia** и **flightsToLisbon** — но такие название слишком частные. Если заказчик захочет полететь в какой-нибудь канадский Виннипег вместо Валенсии, переменную придёя переименовывать. И так каждый раз, когда направление полёта поменяется.

Можно отталкиваться не от направления, а от класса перелёта, и назвать переменные **flightsEconom** и **flightsBusiness**. Такой вариант тоже не самый лучший, потому что мы летаем в разные города, меняется не только класс, но и расстояния.

Назовём переменные максимально просто: **flightsVariantFirst** и **flightsVariantSecond**. Тогда внутри у них могут быть любые расстояния и классы перелёта.
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  if (distance > 3500) {
    percent += 0.15;
  }
  return distance * percent;
};

var calculateFlights = function (distance, isBusinessClass, milesTarget) {
  var miles = calculateMiles(distance, isBusinessClass);
  var flights = Math.ceil(milesTarget / miles);
  return flights;
};

var flightsVariantFirst = calculateFlights(3118, true, 15000);

console.log('Необходимое количество полётов в бизнес-классе до Валенсии: ' + flightsVariantFirst);

var flightsVariantSecond = calculateFlights(3617, false, 15000);

console.log('Необходимое количество полётов в экономе до Лиссабона: ' + flightsVariantSecond);

```
***
## Пример восемнадцать:
Осталось совсем немного!

Сейчас мы знаем результаты и для Валенсии, и для Лиссабона. Осталось добавить код, который сравнит их и скажет, как нашему заказчику быстрее оказаться в заветном Токио. Используем условия **if...else**. Чем меньше полётов надо потратить на накопление миль, тем лучше.
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  if (distance > 3500) {
    percent += 0.15;
  }
  return distance * percent;
};

var calculateFlights = function (distance, isBusinessClass, milesTarget) {
  var miles = calculateMiles(distance, isBusinessClass);
  var flights = Math.ceil(milesTarget / miles);
  return flights;
};

var flightsVariantFirst = calculateFlights(3118, true, 15000);
var flightsVariantSecond = calculateFlights(3617, false, 15000);

console.log('Необходимое количество полётов в бизнес-классе до Валенсии: ' + flightsVariantFirst);
console.log('Необходимое количество полётов в экономе до Лиссабона: ' + flightsVariantSecond);
if(flightsVariantFirst > flightsVariantSecond){
  console.log('Быстрей накопишь полётами в экономе до Лиссабона! Количество полётов: ' +  flightsVariantSecond);
}
  else  {
    console.log('Быстрей накопишь полётами в бизнесе до Валенсии! Количество полётов: ' +  flightsVariantFirst);
  }
```
***
## Пример девятнадцать:
Мы узнали, что мили до Токио проще накопить полётами до Лиссабона в экономе. А что с остальными городами? Заказчик предупреждал, что Токио — только часть его плана. Кроме Токио он хочет бесплатно слетать в Саскатун (3000 миль) и Асунсьон (7500 миль).

Конечно, мы не будем вызывать функцию **calculateFlights** самостоятельно для каждого расстояния. Мы запишем все мили в массив (не забудем добавить туда Токио) и будем его перебирать, вызывая на каждой итерации функцию **calculateFlights** для полётов в Валенсию и Лиссабон. В функцию будем передавать текущий элемент массива — необходимое количество миль для полёта в какой-то город из списка.

Чем удобно использование массива и цикла? Мы можем масштабировать решение на любое количество городов. Будь их хоть 2, хоть 10 или даже 100. Цикл будет перебирать массив, вызывать функцию для подсчёта полётов, а затем сравнивать результаты. И так для каждого элемента массива.

Давайте добавим массив с циклом и, наконец, скажем, как заказчику копить на путешествия его мечты
```javascript
var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  if (distance > 3500) {
    percent += 0.15;
  }
  return distance * percent;
};

var calculateFlights = function (distance, isBusinessClass, milesTarget) {
  var miles = calculateMiles(distance, isBusinessClass);
  var flights = Math.ceil(milesTarget / miles);
  return flights;
};

var targets = [3000, 7500, 15000];

for(var i = 0; i <= targets.length -1; i++){
  var flightsVariantFirst = calculateFlights(3118, true, targets[i]);
  var flightsVariantSecond = calculateFlights(3617, false, targets[i]);

console.log('Необходимое количество полётов в бизнес-классе до Валенсии: ' + flightsVariantFirst);
console.log('Необходимое количество полётов в экономе до Лиссабона: ' + flightsVariantSecond);

if (flightsVariantFirst > flightsVariantSecond) {
  console.log('Быстрей накопишь полётами в экономе до Лиссабона! Количество полётов: ' + flightsVariantSecond);
} else {
  console.log('Быстрей накопишь полётами в бизнесе до Валенсии! Количество полётов: ' + flightsVariantFirst);
}

  }

```
***
## Конспект по функциям(2):
```javascript
// Функция подсчёта миль

var calculateMiles = function (distance, isBusinessClass) {
  var percent = 0.18;
  if (isBusinessClass) {
    percent += 0.04;
  }
  if (distance > 3500) {
    percent += 0.15;
  }
  return distance * percent;
};


// Функция, которая считает количество полётов

var calculateFlights = function (distance, isBusinessClass, milesTarget) {
  // Вызываем одну функцию из другой
  var miles = calculateMiles(distance, isBusinessClass);
  var flights = Math.ceil(milesTarget / miles);
  return flights;
};


// Массив миль, которые нужно накопить

var targets = [1500, 3000, 5000, 7500, 10000, 15000];


// Цикл, в котором выясняется, какими перелётами мили накопятся быстрей

for (var i = 0; i < targets.length; i++) {
  var flightsVariantFirst = calculateFlights(3118, true, targets[i]);
  var flightsVariantSecond = calculateFlights(3617, false, targets[i]);

  console.log('Необходимое количество полётов в бизнес-классе до Валенсии: ' + flightsVariantFirst);
  console.log('Необходимое количество полётов в экономе до Лиссабона: ' + flightsVariantSecond);

  if (flightsVariantFirst > flightsVariantSecond) {
    console.log('Быстрей накопишь полётами в экономе до Лиссабона! Количество полётов: ' + flightsVariantSecond);
  } else {
    console.log('Быстрей накопишь полётами в бизнесе до Валенсии! Количество полётов: ' + flightsVariantFirst);
  }
}
```
