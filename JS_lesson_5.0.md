# ФУНКЦИИ.
***
## Пример один:

Вы только хотели отдохнуть, но вдруг получили ТЗ с пометкой «срочно».

- Я хочу поехать в отпуск. Говорят, в Иркутске водится вкусный омуль, питерская корюшка мне совсем приелась.

- Посчитайте, сколько бонусных воздушных миль я смогу получить с перелёта компанией «Шрек7». Моё чутье охотника за скидками подсказывает, что тут есть, чем поживиться.

- Расстояние до Иркутска 4125 км. Количество миль равно 25% от этого расстояния.

**Жду результата!**

Для начала проясним, что такое «воздушные мили». Так называются бонусы от авиакомпаний, которые можно накапливать после каждого полёта, а затем «оплатить» ими перелёт в какой-нибудь город. Бонусные мили не всегда связаны с настоящими физическими милями. Зачастую это бонусные очки, которые можно накопить до какой-то суммы. Бонусные мили начисляются по-разному. В «Шрек7», как мы уже узнали, бонусы — процент от расстояния перелёта.

В нашем коде расстояние хранится в переменной distance, а процент уже переведён в дробное число и хранится в переменной percent.

Этих значений достаточно, чтобы получить нужное количество миль: умножим расстояние на процент.

```javascript
var percent = 0.25;
var distance = 4125;

var miles = distance * percent;

console.log('За полёт в Иркутск получим ' + miles + ' миль');

```
***
## Пример два:
Вы не первый день работаете  с заказчиком и знаете его шальной характер. Сегодня он летит в Иркутск, а завтра захочет куда-нибудь ещё.

Давайте подстрахуемся и улучшим нашу программу, чтобы она учитывала условие для дальних перелётов.

Если расстояние больше 10500 км, то количество начисленных миль составляет 35% от дальности полёта, а не 25%, как было изначально.
```javascript
var percent = 0.25;
var distance = 4125;

if (distance > 10500) {
  percent = 0.35;
}

var miles = distance * percent;

console.log('За полёт в Иркутск получим ' + miles + ' миль');

```
***
## Пример три:
Спасибо за расчёт!

Когда вернусь, хочу ещё слетать на Камчатку, поесть микижи да на вулканы посмотреть.

Сколько я накоплю миль? Лететь аж 9 часов, мои страдания должны быть вознаграждены!

Ваше чутьё вас не подвело! Задумано ещё одно путешествие, а у вас всё готово: формула есть, условие для дальних перелётов учтено.

Добавим расчёт миль для полёта на Камчатку.

Для этого нам придётся повторить все шаги вычислений для первого путешествия. Алгоритм тот же, только расстояние другое, а может, и проценты. Проверим!

Вы можете заметить, что результаты наших расчётов получаются не круглыми. Всё в порядке, это не ошибка, так работают вычисления в JavaScript. Чуть позже мы сделаем числа круглыми. А в дальнейших курсах обсудим, почему так происходит.

```javascript
var percent = 0.25;
var distance = 4125;

if (distance > 10500) {
  percent = 0.35;
}

var miles = distance * percent;

console.log('За полёт в Иркутск получим ' + miles + ' миль');

var percent = 0.25;
var distance = 11000;

if (distance > 10500) {
  percent = 0.35;
}

var miles = distance * percent;

console.log('За полёт на Камчатку получим ' + miles + ' миль');
```

***
## Пример четыре:
Вы уже заметили проблему?

Программа работает, мили считаются, но что будет, если  пойдёт вразнос и заказчик решит слетать ещё в десяток городов? Нам постоянно придётся копировать одну часть кода, менять расстояние, считать, а ещё каждый раз заново объявлять одни и те же переменные, что нарушает правила языка. Мы, конечно, справимся с поставленной задачей, но потратим много времени, да и код разрастётся до сотни строк.

Есть ли более удобный и грамотный способ сделать вычисления без копирования? Есть! Написать функцию.

Функция — кусок кода, который можно написать один раз, а затем многократно использовать. Функция не просто содержит в себе значение, как переменная, а выполняет какое-то действие и решает какую-то задачу: считает, сравнивает, ищет. Например, наша функция будет вычислять накопленные мили с перелёта.

Но сначала посмотрим, из чего состоят функции и как они объявляются (создаются) в коде.
```javascript
var functionName = function () {
  // Действия, которые выполняет функция или «тело функции»
};
```
**functionName** — имя переменной, которая содержит в себе функцию. По этому имени мы сможем обращаться к функции и использовать её много раз. Давайте считать, что название переменной это и есть название функции.

Есть и другие способы создания функций, о них мы поговорим позже, в других курсах.

Функции создаются не сложнее условий или циклов. Используем ключевое слово function, дальше добавляем круглые скобки. В фигурных скобках находятся действия, которые функция будет делать каждый раз, как мы к ней обратимся. Помните, как в циклах? Там код внутри { } называется «телом цикла», а здесь «телом функции».

**Напишем функцию calculateMiles для расчёта миль.**

Кстати,обратите внимание на название calculateMiles. Функция буквально вычисляет мили, то есть что-то делает. Это общепринятое правило именования — название функции должно содержать глагол. Так разработчикам удобней ориентироваться в своём и даже чужом коде. Может быть, функцию написал ваш коллега, и вы понятия не имеете, что там внутри. Вам достаточно будет посмотреть на имя функции, чтобы примерно представить, для чего она предназначена.
```javascript

var calculateMiles = function(){
 var percent = 0.25;
 var distance = 4125;

 if (distance > 10500) {
  percent = 0.35;
}

var miles = distance * percent;
console.log('За полёт в Иркутск получим ' + miles + ' миль');

};
```
***
## Пример пять:
Функция готова, а дальше-то что? Как вычислить количество миль?

Чтобы функция начала свою работу, её надо вызвать. Для этого нам и пригодится имя функции. Именно по нему мы обратимся к нашей функции и попросим её выполнить свой код.

Если мы просто выведем функцию console.log(functionName), то увидим в консоли весь код этой функции примерно в таком же виде, как его и написали, но никаких вычислений не произойдёт.

Как же тогда запустить код из тела функции?

Нужно обратиться к функции по её имени, а затем указать круглые скобки.

**functionName();**

Обратите внимание, что вызов функции должен идти в коде после её определения.

Давайте проверим, как работает вызов функции, и вызовем нашу функцию calculateMiles.
```javascript
var calculateMiles = function () {
  var distance = 4125;
  var percent = 0.25;
  if (distance > 10500) {
    percent = 0.35;
  }
  var miles = distance * percent;
  console.log('За полёт в Иркутск получим ' + miles + ' миль');
};


calculateMiles();
```
***
## Пример шесть:
Мы написали функцию, вызвали её и посчитали мили, накопленные полётом в Иркутск. А что с полётом на Камчатку? Как посчитать результат второго путешествия?

Тут пригодится очередная фишка функций.

Мы можем записать хоть десять вызовов calculateMiles(), результат будет одинаковым, потому что внутри функции находятся переменные с фиксированными значениями, подходящими только для полёта в Иркутск. То есть **только для одного случая.**

Внутри функции в переменной distance мы храним расстояние до Иркутска. Чтобы найти мили за другой полёт, надо поменять значение этой переменной. Но мы не будем заново переписывать функцию с другим значением distance. Мы сделаем функцию универсальной, чтобы её можно было написать один раз, а затем использовать под разные случаи. Для этого мы будем использовать параметры.

**Параметры** — значения, с помощью которых можно настраивать функции. Так мы можем узнать результат работы функции для разных случаев.

Посмотрим, как это работает.
```javascript
var showTime = function (hours, minutes) {
  console.log('Текущее время: ' + hours + ':' + minutes);
};

showTime(3, 15);    // Выведет: Текущее время: 3:15
showTime(16, 20);   // Выведет: Текущее время: 16:20
```
Чтобы функция работала с параметрами, их надо как-то передать и дать им названия. Разберёмся, как это делать.

1. **Задаём параметры.**
```javascript
var showTime = function (hours, minutes) {
  …
};
```
В момент объявления функции, в круглых скобках, мы создаём параметры. Здесь всё, как с переменными: сначала задаём параметрам имена, которые описывают, что за значения будут в них записаны. Если параметров несколько, они записываются через запятую.

2. **Используем параметры.**
```javascript
var showTime = function (hours, minutes) {
  console.log('Текущее время: ' + hours + ':' + minutes);
};
```
Параметры работают так же, как переменные. Мы подставляем их вместо фиксированных значений в операции внутри функции. При выполнении кода вместо каждого параметра подставится его значение.

3. **Функция получает значения параметров**
```javascript
showTime(3, 15);    // Выведет: Текущее время: 3:15
showTime(16, 20);   // Выведет: Текущее время: 16:20
```
В предыдущих шагах мы разобрали, как функция работает с полученными параметрами. Но ещё не обсудили как сделать так, чтобы функция их получила. В момент вызова функции мы указываем в круглых скобках те значения, которые окажутся в параметрах. Мы пишем showTime(16, 20) и вместо hours в теле функции подставляется 16, а вместо minutes число 20.

Давайте улучшим наш код, наконец, сделаем функцию **calculateMiles** универсальной и посчитаем накопленные мили за второй полёт.

Кстати,правильно говорить «функция принимает параметры», но при этом мы «передаём функции **аргументы**». Почему аргументы? Речь же шла о параметрах! Дело в том, что параметрами называются значения, которые мы задаём в момент объявления функции. Их же мы используем и в теле функции. А аргументами называют значения, которые мы передаём в функцию при её вызове.
```javascript
var calculateMiles = function (distance) {
  var percent = 0.25;
  if (distance > 10500) {
    percent = 0.35;
  }
  var miles = distance * percent;
  console.log('За полёт получим ' + miles + ' миль');
};

calculateMiles(4125);
calculateMiles(11000);

```

***
## Пример семь:
Отвлечёмся ненадолго от подсчёта миль. С аргументами есть один нюанс — передавать их надо в том же порядке, в котором объявлены параметры функции.

Рассмотрим на примере. У нас есть функция getFavoriteBook, которая выводит в консоль сообщение о любимой книге пользователя. У неё есть два параметра: первый называется userName (имя пользователя), второй bookName (название книги).
```javascript
var getFavoriteBook = function (userName, bookName) {
  console.log('Меня зовут ' + userName + '. Моя любимая книга: ' + bookName);
}
```
Допустим, нашего пользователя зовут Семён, а его любимая книга «Ёжик в тумане». Передадим эти аргументы в функцию. Сначала название книги, а затем имя пользователя:
```javascript
var getFavoriteBook = function (userName, bookName) {
  // Параметр userName хранит 'Ёжик в тумане'
  // Параметр bookName хранит 'Семён'
  …
}

// Вызываем функцию
getFavoriteBook('Ёжик в тумане', 'Семён');
// Выведет: Меня зовут Ёжик в тумане. Моя любимая книга: Семён
```
Кажется что-то пошло не так. Почему мы получили такой результат? Мы ведь передали имя пользователя и название книги — всё, как положено.

Всё дело в порядке переданных значений. Параметры работают, как переменные — значение из аргумента записывается в параметр, а потом используется внутри функции по имени. В нашем случае всё так и произошло. Первый параметр функции — userName, первый аргумент — 'Ёжик в тумане'. Этот аргумент и записался в параметр userName, а аргумент 'Семён' стал параметром bookName. Вы, конечно, знаете, где тут имя, а где название книги, а вот JavaScript нет. Он всё понимает буквально: что первым передали, то и стало первым параметром. Потому что порядок аргументов соответствует порядку параметров в функции. У нас параметры записаны в таком порядке: userName, bookName. Значит, первым должно быть передано имя пользователя, а затем название книги. И никак иначе.
```javascript
var getFavoriteBook = function (userName, bookName) {
  // Параметр userName хранит 'Семён'
  // Параметр bookName хранит 'Ёжик в тумане'
  …
}

// Вызываем функцию
getFavoriteBook('Семён', 'Ёжик в тумане');
// Выведет: Меня зовут Семён. Моя любимая книга: Ёжик в тумане
```
Видите, мы передали аргументы в правильном порядке и сообщение стало корректным.

Обратите внимание, если у функции указан параметр, но аргумент не передан, то значение параметра в теле функции будет undefined — то есть ничего. Будьте внимательны.

Потренируемся вызывать функцию с разным порядком аргументов.

Кстати,в примере мы работали со строками, ещё веселей обстоит ситуация с числами. Если в функцию в неправильном порядке переданы значения разных типов, например, числа и строки, могут получиться неожиданные результаты. Например, может произойти конкатенация и число сложится со строкой, результатом будет строка. Или вы можете получить значение NaN, что означает «not a number». Оно говорит о том, что невозможно найти результат математической операции.

```javascript
var showGreeting = function (name, age) {
  console.log('Привет! Меня зовут ' + name + '. Мне ' + age + ' лет.');
};
showGreeting();           //Привет! Меня зовут undefined. Мне undefined лет.
showGreeting(5);          //Привет! Меня зовут 5. Мне undefined лет.
showGreeting(5,'Настя');  //Привет! Меня зовут 5. Мне Настя лет.
showGreeting('Настя',5);  //Привет! Меня зовут Настя. Мне 5 лет.
```
***
## Пример восемь:
А что, если нам нужно получить значение из функции и как-то дальше его использовать?

Функции умеют возвращать результат своей работы. Мы уже говорили о том, что означает «вернуть значение» в этом задании в главе «Знакомство с JavaScript». Загляните туда, если вам нужно освежить знания.

Если кратко, то функция может выполнить код и отдать результат операций для дальнейшей работы с этим результатом. Он подставится в то место кода, где мы вызвали функцию.
```javascript
var increaseByTwo = function (number) {
  var sum = 2 + number;
  return sum;
};

increaseByTwo(1); // Функция вернёт 3
increaseByTwo(2); // Функция вернёт 4
```
Как работает код из примера?

Чтобы функция вернула значение, мы используем оператор return. После оператора указываем, что именно надо вернуть. В нашем случае значение переменной sum. Когда программа доходит до строки с return, функция отдаёт результат своей работы и выполнение кода из тела функции останавливается, иными словами происходит выход из функции.

**Несколько вещей, которые нужно знать:**

- Код, написанный на **новой строке** после return, не выполняется.
- Функция не может вернуть сразу много значений, она возвращает **только один** результат.
- Если внутри функции нет return или после return не указано, какое значение нужно вернуть, функция вернёт undefined, иными словами, **ничего**.
- Как было сказано выше, результат работы функций можно использовать в других операциях.
```javascript
console.log('Сумма чисел: ' + increaseByTwo(1));
// Выведет: Сумма чисел: 3

console.log('Сумма чисел: ' + increaseByTwo(2));
// Выведет: Сумма чисел: 4
```
Кстати, в JavaScript есть встроенные функции языка, которые возвращают результат своей работы. Таких функций очень много. Вот те из них, которые мы будем использовать в заданиях этой главы для округления чисел:

Math.ceil(number) — принимает на вход число и округляет его до целого в большую сторону
Math.floor(number) — делает то же самое, только округляет в меньшую сторону.
Math.round(number) — округляет число до ближайшего целого значения.
Округлим количество миль в нашей функции calculateMiles. Где это видано, чтобы начислялось дробное число миль?

```javascript
var calculateMiles = function (distance) {
  var percent = 0.25;
  if (distance > 10500) {
    percent = 0.35;
  }
  var miles = Math.floor(distance * percent);
  return miles;
};

console.log('За перелёт в Иркутск получим ' + calculateMiles(4125) + ' миль');
console.log('За перелёт на Камчатку получим ' + calculateMiles(11000) + ' миль');
```

***
## Краткий конспект по функциям:
Пример функции.
```javascript
var calculateSum = function (numberFirst, numberSecond) {
  var sum = numberFirst + numberSecond;
  return sum;
};

calculateSum();     // Вернёт NaN
calculateSum(2);    // Вернёт NaN
calculateSum(2, 5); // Вернёт 7
calculateSum(9, 5); // Вернёт 14
```

В этом примере:

- **calculateSum** — имя, по которому можно обратиться к функции.
- **numberFirst, numberSecond** — параметры функции.
- **return sum;** — место кода, где происходит возвращение sum и выход из функции.
- **calculateSum(2, 5);** — аргументы, которые передаются в функции при вызове. Порядок аргументов такой же, как у параметров функции. Первый аргумент 2 записывается в первый параметр numberFirst, аргумент 5 записывается в параметр numberSecond. Важно соблюдать порядок параметров при вызове функции, чтобы избежать неочевидных ошибок.

***
## Пример девять:


```javascript

```
***
## Пример десять:

```javascript

```
