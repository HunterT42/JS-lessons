# ЦИКЛЫ.
***
## Пример один:

Допустим, в задаче много повторяющихся действий, поэтому без циклов решить её не получится. Давайте разберём цикл for подробнее:
```javascript
for (var i = 0; i < 5; i = i + 1) {
  // повторяющиеся команды, или «тело цикла»
}
```
Как работает цикл for? Он выполняет действия из тела цикла снова и снова, пока условие возвращает true. Что за условие и как грамотно писать циклы, мы сейчас разберёмся.

В круглых скобках записывается код управления циклом. Он состоит из трёх частей, разделённых **';'**. Смысл каждой части такой:

1. Первая часть — подготовительная. Команды отсюда запускаются один раз перед началом работы цикла. Обычно здесь задаётся исходное значение для переменной-счётчика. Можно сказать, что первая часть — стартовая настройка для цикла.

В примере ниже мы создали переменную-счётчик i и задали ей начальное значение 0. Именно этому значению будет равна переменная, когда цикл начнёт свою работу.

Обратите внимание, что в цикле мы создаём переменную-счётчик с помощью var, как в случае с любой другой переменной. Традиционно такая переменная называется i (от слова index), но у неё может быть любое другое название. Например, если цикл считает дни, переменная-счётчик может называться day, а если страницы документа, то page.
```javascript
for (var i = 0; i < 5; i = i + 1) { }
```
2. Вторая часть — проверочная. Она содержит условие и запускается перед каждым новым витком цикла. Условие здесь работает по знакомому вам алгоритму. Если условие возвращает true, цикл делает ещё один виток, иначе цикл завершает свою работу.

    В примере мы указали, что цикл должен работать пока переменная i будет меньше 5.
```javascript
for (var i = 0; i < 5; i = i + 1) { }
```
3. Третья часть — дополняющая, хотя по-научному она называется «законом изменения». Код третьей части запускается после каждого витка цикла. То есть после того, как выполнится код из тела цикла. Обычно там изменяется переменная-счётчик.

      В нашем случае мы указали, что после каждого витка цикла, переменная i должна увеличиваться на единицу.
```javascript
for (var i = 0; i < 5; i = i + 1) { }
```

Мы разобрали, как устроен цикл for в теории. Теперь напишем программу для печати всех страниц в принтере. Количество страниц хранится в переменной totalPages.



```javascript
var totalPages = 7;
for(var page = 0; page < totalPages; page = page + 1){printer.print(page)}
```
> Кстати,создать счётчик в цикле можно и без var. Такая возможность существует для обратной совместимости и пришла к нам из старых версий языка. Там это работало, хотя такой код считался неграмотным. Но в новой версии JavaScript (ES6) такая запись работать не будет. В новой версии по умолчанию включен строгий режим, который запрещает создавать переменные без var, в том числе и счётчик цикла. Не забывайте про var и сразу пишите код грамотно.

***
## Пример два:
Что-то пошло не так, и вместо того, чтобы выводить страницы с первой по седьмую, драйвер выводит пустую страницу и затем страницы с первой по шестую. Рассмотрим, в какой последовательности выполняются части конструкции for на примере:
```javascript
for (var i = 0; i < 5; i = i + 1) {
  console.log(i);
}
```
1. Сначала сработает var i = 0;. Будет создана переменная i, равная 0.

1. Затем выполнится проверка i < 5;. Так как i сейчас равна 0 и это значение меньше 5, условие вернёт true. Это значит, что цикл может продолжить свою работу и перейти к выполнению кода из тела цикла.

1. Выполнится код из тела цикла. В нашем случае в консоль выведется 0 — текущее значение переменной i.

1. Выполнится i = i + 1. Переменная i станет равна 1.

1. Выполнится проверка i < 5;. Она снова вернёт true, так как 1 меньше 5.

1. Снова выполнится тело цикла, затем значение i увеличится на единицу, и так дальше по кругу, пока условие i < 5; не вернёт false. Тогда цикл закончит свою работу.

Теперь посмотрим на пример из предыдущего задания. Почему сначала вывелась пустая страница?

На первом витке, или, по-научному, итерации цикла, переменная page ещё равна нулю. А увеличивается до единицы она уже после первой итерации. Если изменить исходное значение переменной page с 0 на 1, то проблема исчезнет.

А почему страниц шесть, а не семь? Разберём цикл по шагам:

Подготовка: totalPages = 7; page = 0
<<<<<<< HEAD

- 1 итерация: page = 0; 0 < 7? да! Вывод страницы 0; page = 1
- 2 итерация: page = 1; 1 < 7? да! Вывод страницы 1; page = 2
- 3 итерация: page = 2; 2 < 7? да! Вывод страницы 2; page = 3
- 4 итерация: page = 3; 3 < 7? да! Вывод страницы 3; page = 4
- 5 итерация: page = 4; 4 < 7? да! Вывод страницы 4; page = 5
- 6 итерация: page = 5; 5 < 7? да! Вывод страницы 5; page = 6
- 7 итерация: page = 6; 6 < 7? да! Вывод страницы 6; page = 7
- 8 итерация: page = 7; 7 < 7? нет! Завершаем цикл!

Для получения седьмой страницы нужно изменить сравнение с «меньше» на «меньше или равно». В этом случае проверка на восьмом витке цикла сработает и выведется седьмая страница.

- 8 итерация: page = 7; 7 <= 7? да! Вывод страницы 7; page = 8
- 9 итерация: page = 8; 8 <= 7? нет! Завершаем цикл!

=======
1 итерация: page = 0; 0 < 7? да! Вывод страницы 0; page = 1
2 итерация: page = 1; 1 < 7? да! Вывод страницы 1; page = 2
3 итерация: page = 2; 2 < 7? да! Вывод страницы 2; page = 3
4 итерация: page = 3; 3 < 7? да! Вывод страницы 3; page = 4
5 итерация: page = 4; 4 < 7? да! Вывод страницы 4; page = 5
6 итерация: page = 5; 5 < 7? да! Вывод страницы 5; page = 6
7 итерация: page = 6; 6 < 7? да! Вывод страницы 6; page = 7
8 итерация: page = 7; 7 < 7? нет! Завершаем цикл!

Для получения седьмой страницы нужно изменить сравнение с «меньше» на «меньше или равно». В этом случае проверка на восьмом витке цикла сработает и выведется седьмая страница.

8 итерация: page = 7; 7 <= 7? да! Вывод страницы 7; page = 8
9 итерация: page = 8; 8 <= 7? нет! Завершаем цикл!
>>>>>>> master
Подытожим: чтобы всё печаталось, как надо, нужно начать отсчёт со страницы номер 1 и использовать знак <= в условии, чтобы включить последнюю страницу в расчёт.
```javascript
var totalPages = 5;

for (var page = 1; page <= totalPages; page = page + 1) {
  keks.print(page);
}
```
***
## Пример три:
Режим работы драйвера завершён! Теперь принтер может печатать все страницы документа и копии заданной страницы. Впечатляет.

Переходим к следующему режиму: печати страниц в обратном порядке.

Это нужная и полезная функция. Если напечатать страницы в обратном порядке, то их можно сразу сшивать в один документ без необходимости переворачивать.

Вы уже знаете все детали работы цикла for, так что остальные режимы реализуете без проблем.

Для печати в обратном порядке сначала нужно вывести последнюю страницу, затем предпоследнюю и так далее, пока не дойдём до первой. Что это значит в терминах циклов:

- На подготовительном шаге нужно установить номер страницы равным количеству страниц в документе.
- Перед каждой итерацией цикла проверяем, что номер страницы больше нуля (либо больше или равен единице).
- После каждой итерации номер страницы нужно уменьшать на единицу, а не увеличивать, как мы делали ранее.
```javascript
var totalPages = 5;

for (var page = totalPages; page >= 1; page = page - 1) {
  keks.print(page);
}
```
***
## Пример четыре:
Как быстро пошла работа! Вспоминаем, что ещё должен уметь принтер:

Новый принтер достаточно простой, он должен уметь печатать все страницы в прямом и обратном порядке, печатать чётные и нечётные страницы и делать копии одной страницы.
Осталась печать чётных и нечётных. Печатать только нечётные страницы легко:

Начинать печать нужно с первой страницы.
После каждой итерации цикла нужно увеличивать номер текущей страницы на 2, а не на 1.
Наверное вы уже заметили, что в циклах постоянно используется увеличение или уменьшение переменных на какое-то число. И нам постоянно приходится писать громоздкие конструкции, типа page = page + 1. К счастью, в JavaScript есть несколько удобных операторов, которые позволяют сократить код. Вот они:


Инкремент (увеличение на единицу) **'i++'** равносильно **'i' = 'i + 1'**
Декремент (уменьшение на единицу) **'i--'** равносильно **'i' = 'i - 1'**
К-к-комбо **'i += 2'** равносильно '**i = i + 2'**
Комбинировать можно не только сложение, но и остальные математические операции: вычитание , умножение , деление  и нахождение остатка.
```javascript
var totalPages = 12;

for (var page = 1; page <= totalPages; page += 2) {
  keks.print(page);
}
```
***
## Пример пять:
Теперь давайте рассмотрим драйвер, который в зависимости от выбранного режима работы будет печатать страницы.

```javascript
var mode = 'document'; // Режим работы драйвера печати('pageCopy','document','reverse','alternate')
var pageNumber = 5; // Номер копируемой страницы
var copyCount = 7; // Количество копий
var totalPages = 6; // Всего страниц в документе
var startPage = 1; // Стартовая страница

if (mode === 'pageCopy') { //Режим копирования одной страницы
  for (var copies = 1; copies <= copyCount; copies++) {
    keks.print(pageNumber);
  }
}

if (mode === 'document'){ //Режим печати всех страниц
   for (var page = 1; page <= totalPages; page++) {
     keks.print(page);
   }
}
if (mode === 'reverse') { //Реверсивный режим печати
  for (var reversePage = totalPages; reversePage >= 1; reversePage--) {
    keks.print(reversePage);
  }
}
if (mode === 'alternate') {//Режим  чётные и нечётные страницы
  for (var alternatePage = startPage; alternatePage <= totalPages; alternatePage+=2) {//чтобы вывести четные страницы меняем значение 'startPage' на 2
    keks.print(alternatePage);
  }
}
```
***
## Пример шесть:
Внутри циклов можно не только запускать печать страниц, но и использовать обычные математические операции. Например, сложение:
```javascript
for (var i = 1; i <= 5; i++) {
  console.log(2 + 2);
}
```

Результат программы будет таким:
```javascript
LOG: 4 (number)
LOG: 4 (number)
LOG: 4 (number)
LOG: 4 (number)
LOG: 4 (number)
```
Число 4 выведется в консоль 5 раз, ведь именно столько итераций в этом цикле. То есть на каждой итерации двойки будут складываться и выводиться в консоль. Но если на каждой итерации нам нужно получать новое, увеличенное, число, надо действовать по-другому. Нужно завести перед циклом ещё одну переменную, которая и будет хранить сумму:
```javascript
var sum = 0;

for (var i = 1; i <= 5; i++) {
  sum += 2;
  console.log(sum);
}
```
Программа выведет:
```javascript
LOG: 2 (number)
LOG: 4 (number)
LOG: 6 (number)
LOG: 8 (number)
LOG: 10 (number)
```
Теперь на каждой итерации мы добавляем 2 к переменной sum, накапливая её значение. Переменная sum объявлена снаружи цикла (а не внутри тела цикла, что важно), поэтому её значение не сбрасывается при попадании в тело цикла, а увеличивается на 2.

Такая операция называется накоплением значения в цикле.

Давайте теперь накапливать значения и посчитаем сумму чисел от 1 до 10. Будем выводить в консоль промежуточные результаты, чтобы следить за изменениями суммы.
```javascript
for (var i = 1,summa = 0; i <= 10; i++){
  summa +=i;
  console.log('i: '+ i);// выводим числа до 10 включительно
  console.log('summa: '+ summa)//выводим сумму чисел
}
```
До этого мы писали циклы внутри условий, но можно и наоборот! Если добавить условие внутрь цикла, то оно будет проверяться на каждой итерации.

Например, можно проверять значение счётчика, и если оно больше двух, прибавлять к сумме 3, а не 2.
```javascript
var sum = 0;

for (var i = 1; i <= 5; i++) {
  if (i > 2) {
    sum += 3;
  } else {
    sum += 2;
  }
  console.log(sum);
}
```
Результат программы:
```javascript
LOG: 2 (number)
LOG: 4 (number)
LOG: 7 (number)
LOG: 10 (number)
LOG: 13 (number)
```
Теперь будем добавлять условия в циклы. Добавим проверку в наш предыдущий цикл. Если значение счётчика больше 5 будем прибавлять к summma число 2.
```javascript
for (var i = 1,summa = 0; i <= 10; i++){
  if(i>5){
  summma +=2;// если переменная i больше 5, тогда прибавляем 2
  }
  else{
     summma += i;
    }
  console.log('i: '+ i);
  console.log('summa: '+ summa)
}
```
***
## Пример семь:
Проверки в циклах очень удобны. Они позволяют делать проверки на каждой итерации цикла.

Например, в цикле из прошлых заданий будем проверять чётное ли сейчас число i. И если число чётное, будем прибавлять к сумме 2, а если число нечётное, будем прибавлять 1.

Как проверить, что число чётное? Здесь может помочь оператор %. Он называется остаток от деления и, как понятно из названия, возвращает остаток от деления.
```javascript
10 % 5;  // Вернёт 0
12 % 5;  // Вернёт 2
7 % 3;   // Вернёт 1
5.5 % 2; // Вернёт 1.5
```
Как это поможет в определении чётного или нечётного числа? Чётное число делится на 2 без остатка. Поэтому, если деление i % 2 возвращает 0 — число чётное, иначе число нечётное.

Напишем проверку с использованием % в нашем цикле.

```javascript
for (var i = 1,summa = 0; i <= 10; i++) {
  console.log('i: ' + i);
  if(i % 2 === 0){
   console.log('чётное число')
  }
  else{
  console.log('нечётное число')
   }
  }
```
***
## Подытожим:
**Цикл for**

Синтаксис
```javascript
for (var i = 0; i < 10; i++) {
  // повторяющиеся команды
}
```
var i = 0; — подготовительная часть, исходное значение для счётчика. Задаётся с помощью var, как обычная переменная.

i < 10; — проверочная часть. Если условие возвращает true, цикл делает ещё одну итерацию иначе прекращает свою работу.

i++ — дополняющая часть, запускается на каждой итерации после выполнения кода из тела цикла. Меняет значение счётчика.

Накопление значений в цикле:
```javascript
var sum = 0;

for (var i = 1; i <= 5; i++) {
  sum += 2;
  console.log(sum);
}
```
Программа выведет:
```javascript
LOG: 2 (number)
LOG: 4 (number)
LOG: 6 (number)
LOG: 8 (number)
LOG: 10 (number)
```
Проверки в теле цикла
```javascript
var sum = 0;

for (var i = 1; i <= 5; i++) {
  if (i > 2) {
    sum += 1;
  }
}
```
**Поиск чётного числа**
Оператор % или «остаток от деления» возвращает остаток от деления.
```javascript
10 % 5;  // Вернёт 0
12 % 5;  // Вернёт 2
7 % 3;   // Вернёт 1
5.5 % 2; // Вернёт 1.5
```

Если остаток от деления числа на 2 равен 0 — число чётное, иначе нечётное.

**Цикл while**

**Синтаксис**
```javascript
while (условие) {
  действия
}
```
Действия будут выполняться снова и снова пока условие не вернёт false.

Накопление значений в цикле
```javascript
var sum = 0;
var i = 0;

while (i <= 5) {
  sum += 1;
  i++;
  console.log(i);
}
```
Программа выведет:
```javascript
LOG: 1 (number)
LOG: 2 (number)
LOG: 3 (number)
LOG: 4 (number)
LOG: 5 (number)
LOG: 6 (number) // Код из тела цикла не выполнится, условие вернёт false
```
**Поиск процента от числа**

Самый простой способ найти процент от числа — разделить число на 100 и умножить на процент.
```javascript
// Найдём 2 процента от 1000
1000 / 100 * 2 = 20;

// Найдём 7 процентов от 1200
1200 / 100 * 7 = 84;
```
