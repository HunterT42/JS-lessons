# JavaScript для новичков.
***
## Пример один:
Москва не сразу строилась, поэтому начнем с малого, с алгоритмов шифрования. Вот техническое задание:

**Я научился шифровать, и мне нужна программа расшифровки.**

- Есть массив symbols, в котором хранится алфавит (буквы и другие символы).

- Есть массив encodedMessage, в котором хранится зашифрованное сообщение. Каждый элемент этого массива — это индекс символа из массива symbols.

- Программа дешифровки должна переводить элементы из массива с шифровкой (encodedMessage) в символы из массива алфавита (symbols) и склеивать из них расшифрованную строку. Эту строку запиши в переменную decodedMessage.

Дано:
```javascript
// Алфавит
var symbols = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', ' ', '.', ',', '—', '!'];

// Закодированное сообщение
var encodedMessage = [18, 38, 46, 62, 66, 50, 33, 41, 66, 49, 48, 38, 58, 62, 68, 66, 48, 37, 42, 47, 66, 50, 33, 41, 66, 49, 48, 51, 49, 42, 67];

// Раскодированное сообщение
var decodedMessage = '';

```
Решение:
```javascript
// Алфавит
var symbols = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', ' ', '.', ',', '—', '!'];

// Закодированное сообщение
var encodedMessage = [18, 38, 46, 62, 66, 50, 33, 41, 66, 49, 48, 38, 58, 62, 68, 66, 48, 37, 42, 47, 66, 50, 33, 41, 66, 49, 48, 51, 49, 42, 67];

// Раскодированное сообщение
var decodedMessage = '';

for(var i = 0; i <= encodedMessage.length - 1; i++){
  decodedMessage += symbols[encodedMessage[i]];
  }
console.log(decodedMessage);
```

***
## Пример два:
Теперь давайте поменяем местами значения массивов:

```javascript
var usersByDay = [4, 1, 2, 3];//первый массив
console.log(usersByDay);

var swap = usersByDay[0];// создаем переменную, в которую записываем нулевой элемент массива

usersByDay[0] = usersByDay[1];//присваиваем нулевому элементу значение первого элемента

console.log(usersByDay);

usersByDay[1] = swap;//записываем значение первого элемента массива в перменную swap

console.log(usersByDay);//выводим результат

```
***
## Пример три:

С перестановкой элементов попрактиковались. Подытожим, зачем нужна вспомогательная переменная. Допустим, есть массив, в котором мы меняем местами первый и второй элементы без вспомогательной переменной:
```javascript
var numbers = [1, 2, 3];

// Теперь numbers такой [2, 2, 3]
numbers[0] = numbers[1];
```
Если сразу записать на первое место значение второго элемента, то мы потеряем значение первого элемента. Поэтому сначала нужно значение первого элемента сохранить в переменную:

```javascript
var numbers = [1, 2, 3];

// Теперь в swap хранится 1
var swap = numbers[0];

// Теперь numbers такой [2, 2, 3]
numbers[0] = numbers[1];

// Теперь numbers такой [2, 1, 3]
numbers[1] = swap;
```
**Следующий шаг на пути к сортировке — поиск минимального элемента. И этот элемент мы будем искать не во всём массиве, а в указанной его части.**

- Для этого заведём переменную currentIndex. Она будет управлять начальным значением переменной цикла. Обратите внимание, что переменная цикла в этот раз будет называться j (это ещё одно типовое название).

```javascript
var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++){
  console.log(usersByDay[j]);
  }
```
***
## Пример четыре:
Почему начальное значение переменной цикла задано как currentIndex + 1? Это нужно, чтобы искать минимальное значение после элемента с позицией currentIndex.
```javascript
var currentIndex = 0;
// Минимальный элемент ищем начиная со второй позиции
// [4, 2, 1, 3]

var currentIndex = 1;
// Минимальный элемент ищем начиная с третьей позиции
// [4, 2, 1, 3]
```
**Как найти минимальный элемент, расположенный после первого?**

- Добавим переменную minValue для хранения минимального значения.
- Предположим, что первый элемент и есть минимальный. Поэтому до цикла сохраним в minValue значение первого элемента.
- На каждой итерации цикла сравниваем текущий элемент со значением minValue.
- Если текущий элемент меньше minValue, то записываем его в minValue.

Если первый элемент и был минимальный, то в цикле значение minValue не изменится, если же после первого элемента были элементы с меньшим значением, то это значение запишется в minValue в цикле.

В любом случае минимальный элемент будет найден.

```javascript
var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if(usersByDay[j] < minValue){
    minValue = usersByDay[j];
    console.log('Новый минимальный элемент: ' + minValue);
  }
}
console.log('Минимальный элемент: ' + minValue);
```
***
## Пример пять:
Мы научились находить минимальное значение. Почему бы не сделать ещё шаг.

Теперь давайте не просто находить минимальное значение после первого элемента, а записывать это значение на место первого элемента. Для этого нужно немного дополнить алгоритм:

- Добавим переменную minValue для хранения минимального значения.
- Предположим, что первый элемент и есть минимальный. Поэтому до цикла сохраним в minValue значение первого элемента.
На каждой итерации цикла сравниваем текущий элемент со значением minValue.
- **Если текущий элемент меньше minValue, то записываем его в minValue, а затем меняем местами значение первого элемента и текущего.**

После завершения работы цикла на первой позиции массива окажется элемент с минимальным значением. Все остальные элементы будут больше.
```javascript
var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    var swap = usersByDay[currentIndex];
    usersByDay[currentIndex] = minValue;
    usersByDay[j] = swap;
    console.log('Меняю местами ' + swap + ' и ' + minValue);
    console.log('Массив сейчас: ' + usersByDay);
  }
}

console.log('Минимальный элемент: ' + minValue);
```
***
## Пример шесть:
Вы прошлись по всему массиву, нашли минимальный элемент и поместили его на первое место.

Как продолжить сортировку? Очень просто. Теперь нужно повторить всё то же самое со вторым элементом массива: ищем минимальные элементы в оставшейся части массива и помещаем их на второе место.

После этого шага на первой позиции массива окажется самый маленький элемент, на второй позиции — следующий по величине. А на остальных позициях — элементы с более крупными значениями.

Затем нужно будет повторить эти же действия с третьим элементом.

После этого массив будет отсортирован полностью, так как на первых трёх позициях по возрастанию будут размещены минимальные элементы, а на четвёртой позиции автоматически останется максимальный элемент.

Реализуем эти шаги через вставку и копирование кода. Единственное, что будет отличаться в разных кусках — это значение переменной **currentIndex**.

```javascript
//для нулевого элемента

var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    var swap = usersByDay[currentIndex];
    usersByDay[currentIndex] = minValue;
    usersByDay[j] = swap;
    console.log('Меняю местами ' + swap + ' и ' + minValue);
    console.log('Массив сейчас: ' + usersByDay);
  }
}

console.log('На позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);



//для первого элемента

console.log(usersByDay);
currentIndex = 1;
minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    var swap = usersByDay[currentIndex];
    usersByDay[currentIndex] = minValue;
    usersByDay[j] = swap;
    console.log('Меняю местами ' + swap + ' и ' + minValue);
    console.log('Массив сейчас: ' + usersByDay);
  }
}

console.log('На позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);



//для второго элемента

console.log(usersByDay);
currentIndex = 2;
minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    var swap = usersByDay[currentIndex];
    usersByDay[currentIndex] = minValue;
    usersByDay[j] = swap;
    console.log('Меняю местами ' + swap + ' и ' + minValue);
    console.log('Массив сейчас: ' + usersByDay);
  }
}

console.log('На позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);


```

***
## Пример шесть:
Программа для сортировки массива из четырёх элементов готова. Да, она негибкая, и её придётся переписывать для массивов с другим количеством элементов. Но это нестрашно, ведь вы уже умеете делать рефакторинг.

В текущей реализации много повторяющегося кода, в котором меняется только значение переменной currentIndex. Как сделать структуру программы лучше?

Можно взять кусок кода с циклом, который ищет и подставляет на указанное место минимальное значение, и обернуть его в другой цикл. И в этом верхнем, «родительском», цикле наращивать переменную currentIndex.

**Да. Циклы можно вкладывать друг в друга.**

Учтите, что currentIndex должна изменяться не от нуля до длины массива, а от нуля до длины массива, уменьшенной на единицу. Вспомните прошлое задание, в котором мы завершили сортировку для массива, дойдя до предпоследнего элемента (ведь последний элемент автоматически оказался максимальным).

Условие выхода из верхнего цикла давайте писать по аналогии с условием выхода из вложенного цикла:
```javascript
// Цикл до предпоследнего элемента
currentIndex <= usersByDay.length - 2

// Цикл до последнего элемента
j <= usersByDay.length - 1
```
**Решение задачи:**
```javascript
for (var currentIndex = 0; currentIndex <= usersByDay.length -2; currentIndex++){

  var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
    if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      var swap = usersByDay[currentIndex];
      usersByDay[currentIndex] = minValue;
      usersByDay[j] = swap;
      console.log('Меняю местами ' + swap + ' и ' + minValue);
      console.log('Массив сейчас: ' + usersByDay);
    }
  }
}

console.log('На позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);
```

***
## Пример семь:
Вот теперь программа сортировки точно завершена. Осталось её как следует протестировать.

Лучше всего тестировать программу в обычных и в так называемых «граничных» условиях.

Программе сортировки очень «непривычно» получать на вход уже отсортированные по возрастанию или убыванию массивы. Поэтому эти условия для неё граничные. А обычными, даже обыденными, условия будут, если на входе окажутся неотсортированные массивы разной длины.

**В программе в качестве переменных циклов теперь используются i и j. Это традиционная «не-разлей-вода» парочка имён переменных, которая часто используется во вложенных циклах.**
```javascript
var usersByDay = [812, 1360, 657, 1247, 165, 34, 57, 777, 300, 101, 606, 11, 55, 44, 33];
console.log(usersByDay);

for (var i = 0; i <= usersByDay.length - 2; i++) {
  var minValue = usersByDay[i];

  for (var j = i + 1; j <= usersByDay.length - 1; j++) {
    if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      var swap = usersByDay[i];
      usersByDay[i] = minValue;
      usersByDay[j] = swap;
    }
  }
}
console.log(usersByDay);
```
***
## Пример восемь:
Программа сортировки готова и оттестирована. Теперь переходим к подсчёту медианы. Медиана — это срединное значение, то есть это буквально элемент, расположенный посередине массива.

Медиана

Медиана отличается от среднего значения устойчивостью к отклонениям:
```javascript
// Среднее: 3
[1, 2, 3, 4, 5]
// Медиана: 3
[1, 2, 3, 4, 5]

// Среднее: 12
[1, 2, 3, 4, 50]
// Медиана: 3
[1, 2, 3, 4, 50]
```
Медиану легко получить у массива с нечётным количеством элементов. Для этого нужно правильно посчитать индекс среднего элемента. Попробуем вывести формулу:
```javascript
// Длина массива 3, индекс среднего элемента 1
[1, 2, 3]

// Длина массива 5, индекс среднего элемента 2
[1, 2, 3, 4, 5]

// Длина массива 7, индекс среднего элемента 3
[1, 2, 3, 4, 5, 6, 7]
```
Вычитаем из длины массива единицу и делим на два, и индекс найден.

Кекс может присылать массивы данных разной длины, поэтому придётся проверять количество элементов на чётность и в зависимости от этого находить медиану. Для проверки на чётность используем уже знакомый оператор %.

```javascript
var usersByDay = [1, 2, 3, 4, 5];
console.log(usersByDay);

if(usersByDay.length % 2 !== 0){

  var medianIndex = (usersByDay.length - 1) / 2;
  console.log(medianIndex);

  var median = usersByDay[medianIndex];
  console.log(median);

  }
```
