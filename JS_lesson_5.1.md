#МАССИВЫ(ПРАКТИКА).
***
## Пример один:
Москва не сразу строилась, поэтому начнем с малого, с алгоритмов шифрования. Вот техническое задание:

**Я научился шифровать, и мне нужна программа расшифровки.**

- Есть массив symbols, в котором хранится алфавит (буквы и другие символы).

- Есть массив encodedMessage, в котором хранится зашифрованное сообщение. Каждый элемент этого массива — это индекс символа из массива symbols.

- Программа дешифровки должна переводить элементы из массива с шифровкой (encodedMessage) в символы из массива алфавита (symbols) и склеивать из них расшифрованную строку. Эту строку запиши в переменную decodedMessage.

Дано:
```javascript
// Алфавит
var symbols = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', ' ', '.', ',', '—', '!'];

// Закодированное сообщение
var encodedMessage = [18, 38, 46, 62, 66, 50, 33, 41, 66, 49, 48, 38, 58, 62, 68, 66, 48, 37, 42, 47, 66, 50, 33, 41, 66, 49, 48, 51, 49, 42, 67];

// Раскодированное сообщение
var decodedMessage = '';

```
Решение:
```javascript
// Алфавит
var symbols = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', ' ', '.', ',', '—', '!'];

// Закодированное сообщение
var encodedMessage = [18, 38, 46, 62, 66, 50, 33, 41, 66, 49, 48, 38, 58, 62, 68, 66, 48, 37, 42, 47, 66, 50, 33, 41, 66, 49, 48, 51, 49, 42, 67];

// Раскодированное сообщение
var decodedMessage = '';

for(var i = 0; i <= encodedMessage.length - 1; i++){
  decodedMessage += symbols[encodedMessage[i]];
  }
console.log(decodedMessage);
```

***
## Пример два:
Теперь давайте поменяем местами значения массивов:

```javascript
var usersByDay = [4, 1, 2, 3];//первый массив
console.log(usersByDay);

var swap = usersByDay[0];// создаем переменную, в которую записываем нулевой элемент массива

usersByDay[0] = usersByDay[1];//присваиваем нулевому элементу значение первого элемента

console.log(usersByDay);

usersByDay[1] = swap;//записываем значение первого элемента массива в перменную swap

console.log(usersByDay);//выводим результат

```
***
## Пример три:

С перестановкой элементов попрактиковались. Подытожим, зачем нужна вспомогательная переменная. Допустим, есть массив, в котором мы меняем местами первый и второй элементы без вспомогательной переменной:
```javascript
var numbers = [1, 2, 3];

// Теперь numbers такой [2, 2, 3]
numbers[0] = numbers[1];
```
Если сразу записать на первое место значение второго элемента, то мы потеряем значение первого элемента. Поэтому сначала нужно значение первого элемента сохранить в переменную:

```javascript
var numbers = [1, 2, 3];

// Теперь в swap хранится 1
var swap = numbers[0];

// Теперь numbers такой [2, 2, 3]
numbers[0] = numbers[1];

// Теперь numbers такой [2, 1, 3]
numbers[1] = swap;
```
**Следующий шаг на пути к сортировке — поиск минимального элемента. И этот элемент мы будем искать не во всём массиве, а в указанной его части.**

- Для этого заведём переменную currentIndex. Она будет управлять начальным значением переменной цикла. Обратите внимание, что переменная цикла в этот раз будет называться j (это ещё одно типовое название).

```javascript
var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++){
  console.log(usersByDay[j]);
  }
```
***
## Пример четыре:
Почему начальное значение переменной цикла задано как currentIndex + 1? Это нужно, чтобы искать минимальное значение после элемента с позицией currentIndex.
```javascript
var currentIndex = 0;
// Минимальный элемент ищем начиная со второй позиции
// [4, 2, 1, 3]

var currentIndex = 1;
// Минимальный элемент ищем начиная с третьей позиции
// [4, 2, 1, 3]
```
**Как найти минимальный элемент, расположенный после первого?**

- Добавим переменную minValue для хранения минимального значения.
- Предположим, что первый элемент и есть минимальный. Поэтому до цикла сохраним в minValue значение первого элемента.
- На каждой итерации цикла сравниваем текущий элемент со значением minValue.
- Если текущий элемент меньше minValue, то записываем его в minValue.

Если первый элемент и был минимальный, то в цикле значение minValue не изменится, если же после первого элемента были элементы с меньшим значением, то это значение запишется в minValue в цикле.

В любом случае минимальный элемент будет найден.

```javascript
var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if(usersByDay[j] < minValue){
    minValue = usersByDay[j];
    console.log('Новый минимальный элемент: ' + minValue);
  }
}
console.log('Минимальный элемент: ' + minValue);
```
***
## Пример пять:
Мы научились находить минимальное значение. Почему бы не сделать ещё шаг.

Теперь давайте не просто находить минимальное значение после первого элемента, а записывать это значение на место первого элемента. Для этого нужно немного дополнить алгоритм:

- Добавим переменную minValue для хранения минимального значения.
- Предположим, что первый элемент и есть минимальный. Поэтому до цикла сохраним в minValue значение первого элемента.
На каждой итерации цикла сравниваем текущий элемент со значением minValue.
- **Если текущий элемент меньше minValue, то записываем его в minValue, а затем меняем местами значение первого элемента и текущего.**

После завершения работы цикла на первой позиции массива окажется элемент с минимальным значением. Все остальные элементы будут больше.
```javascript
var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    var swap = usersByDay[currentIndex];
    usersByDay[currentIndex] = minValue;
    usersByDay[j] = swap;
    console.log('Меняю местами ' + swap + ' и ' + minValue);
    console.log('Массив сейчас: ' + usersByDay);
  }
}

console.log('Минимальный элемент: ' + minValue);
```
***
## Пример шесть:
Вы прошлись по всему массиву, нашли минимальный элемент и поместили его на первое место.

Как продолжить сортировку? Очень просто. Теперь нужно повторить всё то же самое со вторым элементом массива: ищем минимальные элементы в оставшейся части массива и помещаем их на второе место.

После этого шага на первой позиции массива окажется самый маленький элемент, на второй позиции — следующий по величине. А на остальных позициях — элементы с более крупными значениями.

Затем нужно будет повторить эти же действия с третьим элементом.

После этого массив будет отсортирован полностью, так как на первых трёх позициях по возрастанию будут размещены минимальные элементы, а на четвёртой позиции автоматически останется максимальный элемент.

Реализуем эти шаги через вставку и копирование кода. Единственное, что будет отличаться в разных кусках — это значение переменной **currentIndex**.

```javascript
//для нулевого элемента

var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    var swap = usersByDay[currentIndex];
    usersByDay[currentIndex] = minValue;
    usersByDay[j] = swap;
    console.log('Меняю местами ' + swap + ' и ' + minValue);
    console.log('Массив сейчас: ' + usersByDay);
  }
}

console.log('На позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);



//для первого элемента

console.log(usersByDay);
currentIndex = 1;
minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    var swap = usersByDay[currentIndex];
    usersByDay[currentIndex] = minValue;
    usersByDay[j] = swap;
    console.log('Меняю местами ' + swap + ' и ' + minValue);
    console.log('Массив сейчас: ' + usersByDay);
  }
}

console.log('На позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);



//для второго элемента

console.log(usersByDay);
currentIndex = 2;
minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    var swap = usersByDay[currentIndex];
    usersByDay[currentIndex] = minValue;
    usersByDay[j] = swap;
    console.log('Меняю местами ' + swap + ' и ' + minValue);
    console.log('Массив сейчас: ' + usersByDay);
  }
}

console.log('На позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);


```

***
## Пример шесть:
Программа для сортировки массива из четырёх элементов готова. Да, она негибкая, и её придётся переписывать для массивов с другим количеством элементов. Но это нестрашно, ведь вы уже умеете делать рефакторинг.

В текущей реализации много повторяющегося кода, в котором меняется только значение переменной currentIndex. Как сделать структуру программы лучше?

Можно взять кусок кода с циклом, который ищет и подставляет на указанное место минимальное значение, и обернуть его в другой цикл. И в этом верхнем, «родительском», цикле наращивать переменную currentIndex.

**Да. Циклы можно вкладывать друг в друга.**

Учтите, что currentIndex должна изменяться не от нуля до длины массива, а от нуля до длины массива, уменьшенной на единицу. Вспомните прошлое задание, в котором мы завершили сортировку для массива, дойдя до предпоследнего элемента (ведь последний элемент автоматически оказался максимальным).

Условие выхода из верхнего цикла давайте писать по аналогии с условием выхода из вложенного цикла:
```javascript
// Цикл до предпоследнего элемента
currentIndex <= usersByDay.length - 2

// Цикл до последнего элемента
j <= usersByDay.length - 1
```
**Решение задачи:**
```javascript
for (var currentIndex = 0; currentIndex <= usersByDay.length -2; currentIndex++){

  var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
    if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      var swap = usersByDay[currentIndex];
      usersByDay[currentIndex] = minValue;
      usersByDay[j] = swap;
      console.log('Меняю местами ' + swap + ' и ' + minValue);
      console.log('Массив сейчас: ' + usersByDay);
    }
  }
}

console.log('На позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);
```

***
## Пример семь:
Вот теперь программа сортировки точно завершена. Осталось её как следует протестировать.

Лучше всего тестировать программу в обычных и в так называемых «граничных» условиях.

Программе сортировки очень «непривычно» получать на вход уже отсортированные по возрастанию или убыванию массивы. Поэтому эти условия для неё граничные. А обычными, даже обыденными, условия будут, если на входе окажутся неотсортированные массивы разной длины.

**В программе в качестве переменных циклов теперь используются i и j. Это традиционная «не-разлей-вода» парочка имён переменных, которая часто используется во вложенных циклах.**
```javascript
var usersByDay = [812, 1360, 657, 1247, 165, 34, 57, 777, 300, 101, 606, 11, 55, 44, 33];
console.log(usersByDay);

for (var i = 0; i <= usersByDay.length - 2; i++) {
  var minValue = usersByDay[i];

  for (var j = i + 1; j <= usersByDay.length - 1; j++) {
    if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      var swap = usersByDay[i];
      usersByDay[i] = minValue;
      usersByDay[j] = swap;
    }
  }
}
console.log(usersByDay);
```
***
## Пример восемь:
Программа сортировки готова и оттестирована. Теперь переходим к подсчёту медианы. Медиана — это срединное значение, то есть это буквально элемент, расположенный посередине массива.

Медиана

Медиана отличается от среднего значения устойчивостью к отклонениям:
```javascript
// Среднее: 3
[1, 2, 3, 4, 5]
// Медиана: 3
[1, 2, 3, 4, 5]

// Среднее: 12
[1, 2, 3, 4, 50]
// Медиана: 3
[1, 2, 3, 4, 50]
```
Медиану легко получить у массива с нечётным количеством элементов. Для этого нужно правильно посчитать индекс среднего элемента. Попробуем вывести формулу:
```javascript
// Длина массива 3, индекс среднего элемента 1
[1, 2, 3]

// Длина массива 5, индекс среднего элемента 2
[1, 2, 3, 4, 5]

// Длина массива 7, индекс среднего элемента 3
[1, 2, 3, 4, 5, 6, 7]
```
Вычитаем из длины массива единицу и делим на два, и индекс найден.

Кекс может присылать массивы данных разной длины, поэтому придётся проверять количество элементов на чётность и в зависимости от этого находить медиану. Для проверки на чётность используем уже знакомый оператор %.

```javascript
var usersByDay = [1, 2, 3, 4, 5];
console.log(usersByDay);

if(usersByDay.length % 2 !== 0){

  var medianIndex = (usersByDay.length - 1) / 2;
  console.log(medianIndex);

  var median = usersByDay[medianIndex];
  console.log(median);
  }
```

***
## Пример девять:

Примерно та же ситуация происходит с подсчётом медианы, когда в массиве хранится чётное количество элементов. Если количество элементов чётное, то медиана считается как среднее значение от двух элементов: левого и правого от середины.
```javascript
// Медиана: 3
[0, 1, 2, 4, 50, 100]
Снова выводим формулы индексов двух элементов: левого и правого от середины.

// Длина 4, индекс левого 1, правого 2
[1, 2, 3, 4]

// Длина 6, индекс левого 2, правого 3
[1, 2, 3, 4, 5, 6]

// Длина 8, индекс левого 3, правого 4
[1, 2, 3, 4, 5, 6, 7, 8]
```
Делим длину массива на два и вычитаем единицу — левый индекс найден. Делим длину массива на два — правый индекс найден.

Расчёт медианы для чётного количества элементов в массиве добавляем в альтернативной ветке условия.

**Обратите внимание, что этот алгоритм поиска медианы не будет работать на пустых массивах и результатом будет NaN. Всё потому, что в расчёты закрадывается значение undefined, а оно в любых математических операциях даёт NaN.**

```javascript
var usersByDay = [1, 2, 3, 4, 5, 6];
console.log(usersByDay);

if (usersByDay.length % 2 !== 0) {
  var medianIndex = (usersByDay.length - 1) / 2;
  console.log(medianIndex);
  var median = usersByDay[medianIndex];
  console.log(median);
}
else{
var leftIndex = (usersByDay.length) / 2 - 1;
var rightIndex = usersByDay.length / 2;

console.log(leftIndex);
console.log(rightIndex);

var median = (usersByDay[leftIndex] + usersByDay[rightIndex]) / 2;
console.log(median);
}
```

***
## Пример девять:

Сейчас нужно дополнить нашу программу двумя блоками, написанными ранее.

Во-первых, добавим код для сортировки массива. Во-вторых, добавим код для вычисления медианы.

И останется только вывести значение медианного значения в консоль, чтобы видеть, как оно отличается от среднего значения.

```javascript
var expectedUsers = 1000;

var usersByDay = [817, 581, 1370, 752, 1247, 681, 1120, 915, 875, 1341, 757, 610, 812, 741, 11139, 81112, 638, 877, 1242, 1159, 1372, 1170, 845, 1289, 515, 1247, 769, 1261, 2805, 1201];


// Суммируем посещаемость
var totalUsers = 0;
for (var i = 0; i <= usersByDay.length - 1; i++) {
  totalUsers += usersByDay[i];
}

// Рассчитываем среднее значение посещаемости
var averageUsers = totalUsers / usersByDay.length;
console.log('Средняя посещаемость: ' + averageUsers);

if (averageUsers > expectedUsers) {
  console.log('Посещаемость великолепна. Продолжай в том же духе!');
} else {
  console.log('Посещаемость так себе. Нужно поднапрячься!');
}

// Сортируем массив, чтобы медиана была точной(большие числа отправляются в конец массива)

for (var i = 0; i <= usersByDay.length - 2; i++) {
  var minValue = usersByDay[i];

  for (var j = i + 1; j <= usersByDay.length - 1; j++) {
    if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      var swap = usersByDay[i];
      usersByDay[i] = minValue;
      usersByDay[j] = swap;
    }
  }
}


// Рассчитываем медиану

if (usersByDay.length % 2 !== 0) {
  var medianIndex = (usersByDay.length - 1) / 2;
  var median = usersByDay[medianIndex];
} else {
  var leftIndex = usersByDay.length / 2 - 1;
  var rightIndex = usersByDay.length / 2;
  var median = (usersByDay[leftIndex] + usersByDay[rightIndex]) / 2;
}

console.log('Медианная посещаемость: ' + median);
```
***
## Пример десять:
Отлично, уже сейчас видно, что что-то не так. Ведь средняя посещаемость составляет 1032, а медианная 896 человек в день. А это уже ниже ожидаемого значения в тысячу человек.

Есть одна проблема, надо доказать, что среднее и медиана отличаются сильно, не менее, чем на 10 процентов.

В нашем случае очень подозрительно, когда медиана ниже среднего значения. Осталось понять, как посчитать проценты.

Для этого нужно поделить значение медианы на среднее значение. Например, если медиана составляет 80, а среднее значение 100, то:

// Медиана составляет 80% от среднего
80 / 100 = 0.8
Переформулируем задачу: если медиана составляет меньше, чем 0.9 от среднего, то есть подозрения в подтасовках.

Осталось дописать проверку и вывести рекомендации в консоль.

**Теперь наша программа готова!**
```javascript
var expectedUsers = 1000;

var usersByDay = [817, 581, 1370, 752, 1247, 681, 1120, 915, 875, 1341, 757, 610, 812, 741, 1139, 812, 638, 877, 1242, 1159, 1372, 1170, 845, 1289, 515, 1247, 769, 1261, 2805, 1201];

// Рисуем график посещаемости
keks.plot(usersByDay, expectedUsers);

// Суммируем посещаемость
var totalUsers = 0;
for (var i = 0; i <= usersByDay.length - 1; i++) {
  totalUsers += usersByDay[i];
}

// Рассчитываем среднее значение посещаемости
var averageUsers = totalUsers / usersByDay.length;
console.log('Средняя посещаемость: ' + averageUsers);

if (averageUsers > expectedUsers) {
  console.log('Посещаемость великолепна. Продолжай в том же духе!');
} else {
  console.log('Посещаемость так себе. Нужно поднапрячься!');
}

// Сортируем массив
for (var i = 0; i <= usersByDay.length - 2; i++) {
  var minValue = usersByDay[i];

  for (var j = i + 1; j <= usersByDay.length - 1; j++) {
    if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      var swap = usersByDay[i];
      usersByDay[i] = minValue;
      usersByDay[j] = swap;
    }
  }
}

// Рассчитываем медиану
if (usersByDay.length % 2 !== 0) {
  var medianIndex = (usersByDay.length - 1) / 2;
  var median = usersByDay[medianIndex];
} else {
  var leftIndex = usersByDay.length / 2 - 1;
  var rightIndex = usersByDay.length / 2;
  var median = (usersByDay[leftIndex] + usersByDay[rightIndex]) / 2;
}

console.log('Медианная посещаемость: ' + median);

if (median / averageUsers < 0.9) {
  console.log('Есть подозрения в подтасовках!');
} else {
  console.log('Подозрений в подтасовках нет!');
}
```
***
## Подытожим(сортировка массива):
```javascript

var numbers = [12, 3, 7, 9, 10, 5];

for (var i = 0; i <= numbers.length - 2; i++) {
  var minValue = numbers[i];

  for (var j = i + 1; j <= numbers.length - 1; j++) {
    if (numbers[j] < minValue) {
      minValue = numbers[j];
      var swap = numbers[i];
      numbers[i] = minValue;
      numbers[j] = swap;
    }
  }
}

console.log(numbers);
// Выведет: [3, 5, 7, 9, 10, 12];
```
Массив с числами numbers сортируется по возрастанию элементов. На каждой итерации мы сравниваем minValue с остальными элементами массива. Если какой-то из них окажется меньше, чем minValue, он запишется в minValue, перезаписав старое значение, и переместится в начало массива. Переменная swap — вспомогательная переменная, с помощью, которой мы можем поменять элементы местами.
