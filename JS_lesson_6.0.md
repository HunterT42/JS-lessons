# ОБЪЕКТЫ.
***
## Пример один:
 Что будет, если если в параметрах функции будет 10 или даже 100 переменных? Ответ очевиден: функция со параметрами. Но этим путём мы не пойдём.

Есть ли более удобный способ хранения значений, относящихся к одной сущности? Есть, это объекты.

Объект — тип данных, который хранит в себе информацию в виде пар «ключ-значение». Если массив — нумерованный список, где каждый элемент имеет свой порядковый номер, то объект — список, в котором каждый элемент сопоставлен со своим ключом и порядок совсем неважен. Рассмотрим объекты на примере. Опишем объект капибары.

Создаём объект. В первую очередь объект надо создать. Для этого используют уже знакомые вам фигурные скобки { }. Дадим объекту имя, оно задаётся точно так же, как и имя любой переменной.
```javascript
var capybara = {};
// Так создаётся объект с именем capybara
```
Добавляем свойства. Пары «ключ-значение», которые содержит в себе объект, называются свойствами или атрибутами. Выглядят они так:
```javascript
var capybara = {
  name: 'Джон',
  // Добавили новое свойство, где name — ключ, 'Джон' — значение
  age: 5
  // Новое свойство. Ключ — age, значение — 5
};
```
Свойства называются по имени ключа, то есть можно сказать, что у объекта капибара есть свойство для хранения имени, где ключ name, а значение 'Джон' или, что у объекта капибара есть свойство name со значением 'Джон'.

**Несколько правил синтаксиса:**

- Ключ обособляется от значения двоеточием.
- Пары «ключ-значение» отделяются друг от друга запятыми.
- Значениями могут быть данные любого типа (число, строка, массив и так далее).
***
## Пример два:
Теперь давайте рассмотрим вложенные условия на простом бытовом примере. Вы пошли в магазин за молоком. Если молока в магазине не окажется, но будет кефир, вы купите его. Если и кефира не будет, придётся взять йогурт. А вот если и йогурт закончился, вам придётся купить ряженку, хоть вы её не очень-то жалуете. Код с вложенными условиями будет выглядеть так:
```javascript

var isMilk = false;
var isKefir = false;
var isYogurt = true;

if (isMilk) {
  console.log('Отлично! Беру молоко!');
} else {
  if (isKefir) {
    console.log('Тогда возьму кефир!');
  } else {
    if (isYogurt) {
      console.log('Ну и ладно! Куплю йогурт!');
    } else {
      console.log('Ну вот, придётся брать ряженку!');
    }
  }
};

// В консоль выведется: Ну и ладно! Куплю йогурт!
```

Согласитесь, код выглядит громоздко? Есть более удобный способ записи — цепочка условных конструкций. Она подходит, когда необходимо проверить больше двух условий и закончить проверку, если какое-то из условий срабатывает.

Синтаксис вам знаком, только во второй и последующих ветках if можно писать через пробел сразу после else, а затем добавить новое условие. Тогда, если первая проверка не выполняется, программа проверит условие в следующей ветке. Если и там условие неверно, код будет проверяться дальше. В конце конструкции можно добавить ветку с обычным else на случай, если ни одно из предыдущих условий не будет выполнено.

С цепочкой условий код похода в магазин будет выглядеть так:
```javascript
// Массив чисел
var array = [10, 20, 30, 40, 50];

var isMilk = false;
var isKefir = false;
var isYogurt = true;

if (isMilk) {
  console.log('Отлично! Беру молоко!');
} else if (isKefir) {
  console.log('Тогда возьму кефир!');
} else if (isYogurt) {
  console.log('Ну и ладно! Куплю йогурт!');
} else {
  console.log('Ну вот, придётся брать ряженку!');
}

// В консоль выведется: Ну и ладно! Куплю йогурт!
```

Так код выглядит аккуратней, логичней и легко читается.

***
## Пример три:

# !!!ПОЧИНИТЬ!!!
Теперь давайте потренируемся делать простенькую игру на основе пройденного нами материала.
```javascript
var gameRules = {
  diceNumber: 1,
  maxAttempts: 1
};

var firstCat = {
  name: 'Джон',
  points: 0
};

var secondCat = {
  name: 'Рудольф',
  points: 0
};

var thirdCat = {
  name: 'Рокки',
  points: 0
};

var cats = [firstCat, secondCat, thirdCat];

var runGame = function (rules, players) {
  for (var currentAttempt = 1; currentAttempt <= rules.maxAttempts; currentAttempt++) {
    for (var i = 0; i < players.length; i++) {
      var throwResult = keks.throwDice(rules.diceNumber, rules.diceNumber * 6);
      players[i].points += throwResult;
      console.log(players[i].name + ' выбросил ' + players[i].points);
    }
  }
  return players;
};

var getWinners = function (players) {
  var winners = [];
  var max = players[0];

  for (var i = 0; i < players.length; i++) {
    var currentPlayer = players[i];
    if (currentPlayer.points > max.points) {
      max = currentPlayer;
      winners = [max];
    } else if (currentPlayer.points === max.points) {
      winners.push(currentPlayer);
    }
  }

  return winners;
};


var printWinners = function (players, winners) {
  if (players.length === winners.length) {
    console.log('Все коты как на подбор!');
    return;
  }

  var message = 'Победил ';
  if (winners.length > 1) {
    message = 'Победили ';    
  }

  for (var i = 0; i < winners.length; i++) {
    if (i >= 1) {
      message += ', ';      
    }
    message += winners[i].name;
  }

  message += ' с количеством очков: ' + winners[0].points;

  console.log(message);
};

cats = runGame(gameRules, cats);
var tops = getWinners(cats);
printWinners(cats, tops);

```

***
## Конспект(часть 1):

Объект — тип данных, который хранит в себе информацию в виде пар «ключ-значение». Каждый элемент сопоставлен со своим ключом и порядок элементов совсем неважен.
```javascript
var cat = {
  name: 'Джон',
  age: 5
};

console.log(cat.name); // Выведет в консоль: Джон
console.log(cat.age); // Выведет в консоль: 5
console.log(cat.color); // Выведет: undefined. Такого ключа в объекте нет

cat.age++; // Увеличили возраст кота на 1
console.log(cat.age) // Выведет в консоль 6

cat.name = 'Рокки'; // Заменили снаружи значение свойства name
console.log(cat.name); // Выведет в консоль: Рокки
```
### Передача по ссылке
Объект всегда один, в памяти не создаётся новое место под копию объекта. Каждая переменная содержит не новую отдельную сущность, а ссылку на один-единственный объект. Поэтому когда мы меняем что-то в объекте через одну из переменных, в которой содержится ссылка на него, изменения видны во всех других переменных, будь их хоть двадцать или сорок. Это важная особенность объектов, которую надо запомнить. Она так и называется — передача объектов по ссылке.
```javascript
var firstCat = {
  name: 'Джон',
  age: 5
};

var secondCat = firstCat;
console.log(secondCat);
// Выведет: {name:"Джон", age:5}

firstCat.name = 'Снежок';
console.log(secondCat);
// Выведет: {name:"Снежок", age:5}
```

***
## Пример четыре:
У нас новый проект, надо написать компьютерный магазин. Заказчик серьёзный, поэтому всё должно быть по уму. Вот небольшое ТЗ:

- Пользователь выбирает компьютер, а программа выводит результат заказа.
- В сообщении должны быть технические характеристики и итоговая цена товара.
- Есть базовая цена любого компьютера, а конечная сумма зависит от каждого технического показателя устройства.

Жду результата! Не подведи!

Как и прежде, разберём задачу, чтобы понять, из чего будет состоять программа.

Очевидно, что без функции тут не обойдётся. Будем передавать ей выбранный компьютер и получать итоговую сумму. При расчётах необходимо учесть базовую цену устройства и стоимость каждой характеристики. Например, цены компьютеров с экраном 13 и 15 дюймов будут отличаться. Получается, у каждого устройства есть показатели: базовая цена и технические характеристики (оперативная память, процессор и размер дисплея). Иными словами, несколько свойств, относящихся к одной сущности, компьютеру. Вы уже догадались, где мы будем это хранить? Правильно, в объекте.

В итоге у нас получится конфигуратор компьютера. В объекте будем хранить компьютер и его характеристики, а сам объект будем хранить в теле функции. Выбирая какое-то устройство, будем вызывать функцию-конфигуратор, которая будет записывать в объект компьютера его характеристики, считать цену и возвращать её наружу.

Для начала создадим функцию buildComputer, заведём внутри объект computer и проверим, что функция его возвращает.

```javascript
var buildComputer = function (memory, display, processor) {
 var computer = {
   basicPrice: 5000,
   processor: processor,
   display: display,
   memory: memory
   }
   return computer;
};

var myComputer = buildComputer(8,13,'i7');
console.log(myComputer);
```
***
## Пример пять:
Функция и объект созданы. Идём дальше.

Нам надо посчитать цену компьютера и вывести итоговое сообщение. Для этого нужно написать функции, и запишем мы их прямо в объект! Так можно делать!

В объектах могут храниться любые типы данных, в том числе и функции. Такие свойства-функции называются методами объектов. Они вызываются так же, как и любые другие функции, через круглые скобки, а обращаемся мы к методам, как и к свойствам объекта. В итоге вызов метода записывается так: объект.метод().

Главное в создании метода — придумать подходящее название, описывающее, что делает этот метод. В мире программирования есть устоявшиеся традиции именования. Например, функции, которые что-то возвращают, называются геттерами и начинаются со слова get. Это выглядит так:
```javascript
var myCat = {
  name: 'Ёся',
  color: 'черный',
  age: 1,

  getGreeting: function() {
    return 'Мяу, привет!';
  }
};

console.log(myCat.getGreeting()); // Выведет: Мяу, привет!
```
Раз методы это те же функции, почему мы вообще записываем их в объект, а не используем привычные внешние функции?

Методы используются для работы с объектами. Они читают свойства, переписывают их и возвращают. Да, можно создать внешнюю функцию, передавать ей объект и обрабатывать внутри этой функции. Но намного удобней держать в объекте всё, что относится именно к этому объекту. Например, мы храним технические характеристики внутри объекта компьютера, нам нужно возвращать строку с данными и высчитывать цену. Эти две задачи связаны именно с объектом компьютера, поэтому мы будем записывать эти функции в объект.

Создадим простой геттер для объекта компьютера и проверим, всё ли работает, как надо.
```javascript
var buildComputer = function (memory, display, processor) {
  var computer = {
    basicPrice: 5000,
    processor: processor,
    display: display,
    memory: memory,
    getDescription: function () {
      return 'компьютер';
    }
  };

  return computer;
};

var myComputer = buildComputer(8, 13, 'i7');
console.log('В корзине ' + myComputer.getDescription());//Выведет: В корзине компьютер
```
***
## Пример шесть:
Мы убедились, что метод работает в объекте компьютера. Что дальше?

Сейчас мы возвращаем просто слово «компьютер». Но метод getDescription должен возвращать описание устройства со всеми его характеристиками, которые хранятся в свойствах объекта computer. Как это сделать? Можно ли изнутри методов объекта обращаться к его свойствам? Можно! Здесь нет никаких сложностей синтаксиса, пишем, как всегда объект.свойство.

Переопределим метод getDescription. Пусть он возвращает строку с описанием выбранного компьютера. К свойствам, которые хранят технические характеристики устройства будем обращаться через точку изнутри метода.

Кстати, в объекте может быть много методов, а не один. Поэтому мы заведём еще один и назовём его getPrice. Как понятно из названия, он будет возвращать цену компьютера.
```javascript
var buildComputer = function (memory, display, processor) {
  var computer = {
    basicPrice: 5000,
    processor: processor,
    display: display,
    memory: memory,

    getDescription: function () {
      return 'компьютер с процессором ' + computer.processor + ', диагональю ' + computer.display + ', оперативной памятью ' + computer.memory;
    },
    getPrice: function () {
      return computer.basicPrice;
    }
  };

  return computer;
};

var myComputer = buildComputer(8, 13, 'i7');
console.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());
//Выведет: В корзине компьютер с процессором i7, диагональю 13, оперативной памятью 8 стоимостью 5000
```
***
## Пример семь:
Теперь посчитаем цену компьютера. Она состоит из нескольких слагаемых: стартовой цены и стоимости каждой технической характеристики. Расценки:

Процессор 'i5' - 5000
Процессор 'i7' - 10000
Дисплей 13 дюймов - 5000
Дисплей 15 дюймов - 10000
Оперативная память 8 Гб - 3000
Оперативная память 16 Гб - 7000

Выходит, нам нужно проверять значения свойств в объекте компьютера и, в зависимости от результата, прибавлять к базовой цене ту или иную сумму. В итоге мы получим цену устройства. Для проверки каждой характеристики отдельно можно использовать конструкцию else if. Тогда код будет выглядеть примерно так:
```javascript
var price = computer.basicPrice;

if (computer.processor === 'i5') {
  price += 5000;
} else if (computer.processor === 'i7') {
  price += 10000;
}
```
 И так далее суммируем стоимость остальных компонентов
Код рабочий, но не кажется ли он слишком большим? Сейчас у нас только три характеристики, из которых складывается цена устройства, а что, если их станет больше?

В некоторых ситуациях блоки с условиями можно сократить с помощью объектов. Давайте разбираться, как это сделать. Рассмотрим на примере.
```javascript
var printFavoriteFood = function (name) {
  var message = 'Моя любимая еда — ';

  if (name === 'Ёся') {
    message += 'рыба';
  } else if (name === 'Буся') {
    message += 'котлета';
  } else if (name === 'Снежок') {
    message += 'сметана';
  }

  return message;
};

console.log(printFavoriteFood('Снежок')); // Выведет: Моя любимая еда — сметана
```
Обратите внимание, что каждому коту, а точнее его имени, соответствует определённая еда. При этом порядок котов совсем неважен. Можно ли записать вкусовые предпочтения котов в объект? Давайте попробуем.
```javascript
var catsFavoriteFood = {
  Ёся: 'рыба',
  Буся: 'котлета',
  Снежок: 'сметана'
};
```
Можно ли теперь использовать данные в объекте catsFavoriteFood так, чтобы совсем избавиться от условий в теле функции printFavoriteFood? Можно! Перед нами обычный объект со свойствами и их значениями. Значит, мы можем обратиться к свойству объекта и подставить в выражение строку, которая в нём содержится.
```javascript
var catsFavoriteFood = {
  Ёся: 'рыба',
  Буся: 'котлета',
  Снежок: 'сметана'
};

var printFavoriteFood = function (name) {
  return 'Моя любимая еда — ' + catsFavoriteFood[name];
};

console.log(printFavoriteFood('Снежок')); // Выведет: Моя любимая еда — сметана
```
Код работает, как и прежде, зато насколько сократилась наша программа!

Мы записали в объект не характеристику вида name: 'Ёся', а соотношение имени кота и лакомства, которое по вкусу именно ему. Такие объекты называют словарями, мапами или ассоциативными массивами. Они очень удобны в использовании и позволяют писать код чище и проще.

В нашей программе для каждого показателя подходит своя цена, например, для процессора 'i7' это 10000, для дисплея 13 дюймов это 5000. Значит, мы можем сделать словари, которые будут хранить стоимость каждой характеристики, а затем обращаться к свойствам этих объектов, чтобы получить цену.
```javascript
var processorPrice = {
  'i5': 5000,
  'i7': 10000
  };
var displayPrice = {
  13: 5000,
  15: 10000
  };
var memoryPrice = {
  8: 3000,
  16: 4000
  };

var buildComputer = function (memory, display, processor) {
  var computer = {
    basicPrice: 5000,
    processor: processor,
    display: display,
    memory: memory,

    getDescription: function () {
      return 'компьютер с процессором ' + computer.processor + ', диагональю ' + computer.display + ', оперативной памятью ' + computer.memory;
    },

    getPrice: function () {
      return computer.basicPrice;
    }
  };

  return computer;
};

var myComputer = buildComputer(8, 13, 'i7');
console.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());

```
***
## Пример восемь:
Заметили что-то необычное в примере работы со словарём?

Раньше мы обращались к свойствам объекта с помощью точки, а в этом примере работаем с объектом как с массивом — читаем свойство с помощью квадратных скобок: catsFavoriteFood[name]. Да, так тоже можно. Способ со скобками называется скобочной нотацией, способ с точкой — точечной нотацией. Программисты такие оригиналы, не правда ли?

Скобочная нотация намного гибче точечной. Например, вы можете прочитать из объекта свойство, название которого записано в переменную:
```javascript
var name = 'Ёся';
var catsFavoriteFood = { 'Ёся': 'рыба' };

console.log(catsFavoriteFood.name);
// Выведет в консоль: undefined

console.log(catsFavoriteFood[name]);
// Выведет в консоль: рыба
```
Первое сообщение содержит undefined, потому что у объекта нет свойства name. Второе сообщение содержит искомое значение, потому что программа понимает, что в квадратных скобках переменная. Значение переменной подставится в скобки, а затем будет найдено нужное свойство объекта.
```javascript
console.log(catsFavoriteFood[name]);
// Незаметно внутри программы превращается в:
console.log(catsFavoriteFood['Ёся']);
```
И ещё один сюрприз. В качестве ключей в объекте можно использовать любые строки, даже строки с пробелами. С точечной нотацией такие свойства прочитать не получится, а со скобочной — без проблем.
```javascript
var cat = { 'favorite food': 'Сметана' };

console.log(cat.favorite food);
// Вызовет ошибку

console.log(cat['favorite food']);
// Отработает нормально
```
Кстати, почему мы вынесли словари из функции в самое начало программы? Значения, которые хранятся в этих объектах, не зависят от параметров функции или объекта компьютера. Это правила, относящиеся ко всей программе. Их можно использовать в других функциях и операциях, если это понадобится. Если бы словари находились в теле функции, они бы создавались только в момент вызова этой функции.

Почему это вообще работает? Объект внутри функции видит объекты, которые объявлены в самом начале программы. Так работают области видимости. Мы разберём эту особенность языка позже, в других курсах.

Теперь, когда словари созданы, и мы научились с ними работать, можно посчитать цену компьютера одной строкой. Будем использовать метод getPrice. Переопределим его, добавив новые вычисления.
```javascript
var processorPrice = {
  'i5': 5000,
  'i7': 10000
};

var displayPrice = {
  13: 5000,
  15: 10000
};

var memoryPrice = {
  8: 3000,
  16: 4000
};

var buildComputer = function (memory, display, processor) {
  var computer = {
    basicPrice: 5000,
    processor: processor,
    display: display,
    memory: memory,

    getDescription: function () {
      return 'компьютер с процессором ' + computer.processor + ', диагональю ' + computer.display + ', оперативной памятью ' + computer.memory;
    },

    getPrice: function () {
      return computer.basicPrice + processorPrice[computer.processor] + displayPrice[computer.display] + memoryPrice[computer.memory];
    }
  };

  return computer;
};

var myComputer = buildComputer(8, 13, 'i7');
console.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());

```
***
## Пример девять:
Наша программа готова! Вся необходимая функциональность написана! Осталось обсудить ещё один вопрос.

Внутри методов мы обращаемся к свойствам объекта компьютера computer.свойство. А что, если в будущем название объекта изменится и количество свойств увеличится? Придётся везде исправлять computer на что-то новое. Лень — одно из главных качеств разработчика, переписывать названия совсем не хочется. Хорошо, что есть ключевое слово this. Им-то мы и воспользуемся.

this недаром называется именно так. Если в речи такое местоимение указывает на определённый предмет, то в JavaScript ключевое слово this указывает на конкретный объект, а именно на тот объект, на котором была вызвана функция (метод).

Использовать this просто, достаточно заменить название объекта на ключевое слово в обращении к свойству. Вместо объект.свойство используем this.свойство.
```javascript
var cat = {
  name: 'Снежок',

  introduce: function () {
    console.log('Мяу! Я кот ' + this.name + '!');
  }
};

cat.introduce(); // Выведет: Мяу! Я кот Снежок!
```
Объект, на который указывает this называется контекстом вызова.

Важная деталь: пока функция не вызвана, this не содержит никакого значения, контекст появляется только в момент вызова функции.

Ключевое слово this приносит много пользы разработчикам. О других преимуществах и особенностях this вы узнаете позже, в дальнейших курсах, а пока заменим обращение к свойствам внутри объекта computer.

```javascript
var processorPrice = {
  'i5': 5000,
  'i7': 10000
};

var displayPrice = {
  13: 5000,
  15: 10000
};

var memoryPrice = {
  8: 3000,
  16: 4000
};

var buildComputer = function (memory, display, processor) {
  var customComputer = {
    basicPrice: 5000,
    processor: processor,
    display: display,
    memory: memory,

    getDescription: function () {
      return 'компьютер с процессором ' + this.processor + ', диагональю ' + this.display + ', оперативной памятью ' + this.memory;
    },

    getPrice: function () {
      return this.basicPrice + processorPrice[this.processor] + displayPrice[this.display] + memoryPrice[this.memory];
    }
  };

  return customComputer;
};

var myComputer = buildComputer(8, 13, 'i7');
console.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());

```
***
## Пример десять:
Интернет-магазин готов! Осталось проверить, как будет работать программа с другим компьютером. Надо убедиться, что независимо от показателей устройства, сообщение с техническими характеристиками будет выводиться корректно, а цена будет высчитываться верно.

Создадим ещё один компьютер с оперативной памятью 16 Гб, диагональю 15 дюймов и процессором 'i5', узнаем его цену и выведем список характеристик.
```javascript
var processorPrice = {
  'i5': 5000,
  'i7': 10000
};

var displayPrice = {
  13: 5000,
  15: 10000
};

var memoryPrice = {
  8: 3000,
  16: 4000
};

var buildComputer = function (memory, display, processor) {
  var customComputer = {
    basicPrice: 5000,
    processor: processor,
    display: display,
    memory: memory,

    getDescription: function () {
      return 'компьютер с процессором ' + this.processor + ', диагональю ' + this.display + ', оперативной памятью ' + this.memory;
    },

    getPrice: function () {
      return this.basicPrice + processorPrice[this.processor] + displayPrice[this.display] + memoryPrice[this.memory];
    }
  };

  return customComputer;
};

var myComputer = buildComputer(8, 13, 'i7');
console.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());

var anotherComputer = buildComputer(16, 15, 'i5');
console.log('В корзине ' + anotherComputer.getDescription() + ' стоимостью ' + anotherComputer.getPrice());

```
## Конспект(часть 2):
В объектах могут храниться любые типы данных, в том числе и функции. Такие свойства-функции называются методами объектов. Вызов метода записывается так: объект.метод().

Изнутри методов можно обращаться к свойствам и другим методам объекта с помощью ключевого слова this. Оно указывает на текущий объект и называется контекстом вызова.

Важная деталь: пока функция не вызвана, this не содержит никакого значения, контекст появляется только в момент вызова функции.
```javascript
var cat = {
  name: 'Ёся',
  color: 'черный',
  age: 5,

  getGreeting: function() {
    return 'Мяу, привет! Меня зовут ' + this.name;
  }
};

console.log(cat.getGreeting()); // Выведет: Мяу, привет! Меня зовут Ёся
```
Мапы или словари очень удобны в использовании. В нашем примере они хранят соотношение имени кота и лакомства, которое по вкусу именно ему.
```javascript
var catsFavoriteFood = {
  Ёся: 'рыба',
  Буся: 'котлета',
  Снежок: 'сметана'
};

var printFavoriteFood = function (name) {
  // Используем скобочную нотацию
  return 'Моя любимая еда — ' + catsFavoriteFood[name];
};

console.log(printFavoriteFood('Снежок')); // Выведет: Моя любимая еда — сметана
```
